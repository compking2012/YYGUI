/**
 * AutoLayout.js is licensed under the MIT license. If a copy of the
 * MIT-license was not distributed with this file, You can obtain one at:
 * http://opensource.org/licenses/mit-license.html.
 *
 * @author: Hein Rutjes (IjzerenHein)
 * @license MIT
 * @copyright Gloey Apps, 2015
 *
 * @library autolayout.js
 * @version 0.5.2
 */
/**
 * Parts Copyright (C) 2011-2012, Alex Russell (slightlyoff@chromium.org)
 * Parts Copyright (C) Copyright (C) 1998-2000 Greg J. Badros
 *
 * Use of this source code is governed by the LGPL, which can be found in the
 * COPYING.LGPL file.
 */

'use strict';
var c = require('./cassowary');

var _createClass = (function() {
    function defineProperties(target, props) {
        for (var i = 0; i < props.length; i++) {
            var descriptor = props[i];
            descriptor.enumerable = descriptor.enumerable || false;
            descriptor.configurable = true;
            if ('value' in descriptor) descriptor.writable = true;
            Object.defineProperty(target, descriptor.key, descriptor);
        }
    }
    return function(Constructor, protoProps, staticProps) {
        if (protoProps) defineProperties(Constructor.prototype, protoProps);
        if (staticProps) defineProperties(Constructor, staticProps);
        return Constructor;
    };
})();

function _classCallCheck(instance, Constructor) {
    if (!(instance instanceof Constructor)) {
        throw new TypeError('Cannot call a class as a function');
    }
}

/**
 * Layout attributes.
 * @enum {String}
 */
var Attribute = {
    CONST: 'const',
    NOTANATTRIBUTE: 'const',
    VARIABLE: 'var',
    LEFT: 'left',
    RIGHT: 'right',
    TOP: 'top',
    BOTTOM: 'bottom',
    WIDTH: 'width',
    HEIGHT: 'height',
    CENTERX: 'centerX',
    CENTERY: 'centerY',
    /*LEADING: 'leading',
TRAILING: 'trailing'*/
    /** Used by the extended VFL syntax. */
    ZINDEX: 'zIndex'
};

/**
 * Relation types.
 * @enum {String}
 */
var Relation = {
    /** Less than or equal */
    LEQ: 'leq',
    /** Equal */
    EQU: 'equ',
    /** Greater than or equal */
    GEQ: 'geq'
};

/**
 * Layout priorities.
 * @enum {String}
 */
var Priority = {
    REQUIRED: 1000,
    DEFAULTHIGH: 750,
    DEFAULTLOW: 250
    //FITTINGSIZELEVEL: 50,
};

var parser = (function() {
    /*
     * Generated by PEG.js 0.8.0.
     *
     * http://pegjs.majda.cz/
     */

    function peg$subclass(child, parent) {
        function ctor() {
            this.constructor = child;
        }
        ctor.prototype = parent.prototype;
        child.prototype = new ctor();
    }

    function SyntaxError(message, expected, found, offset, line, column) {
        this.message = message;
        this.expected = expected;
        this.found = found;
        this.offset = offset;
        this.line = line;
        this.column = column;

        this.name = "SyntaxError";
    }

    peg$subclass(SyntaxError, Error);

    function parse(input) {
        var options = arguments.length > 1 ? arguments[1] : {},
            peg$FAILED = {},
            peg$startRuleFunctions = {
                visualFormatString: peg$parsevisualFormatString
            },
            peg$startRuleFunction = peg$parsevisualFormatString,
            peg$c0 = peg$FAILED,
            peg$c1 = null,
            peg$c2 = ":",
            peg$c3 = {
                type: "literal",
                value: ":",
                description: "\":\""
            },
            peg$c4 = [],
            peg$c5 = function peg$c5(o, superto, view, views, tosuper) {
                return {
                    orientation: o ? o[0] : 'horizontal',
                    cascade: (superto || []).concat([view], [].concat.apply([], views), tosuper || [])
                };
            },
            peg$c6 = "H",
            peg$c7 = {
                type: "literal",
                value: "H",
                description: "\"H\""
            },
            peg$c8 = "V",
            peg$c9 = {
                type: "literal",
                value: "V",
                description: "\"V\""
            },
            peg$c10 = function peg$c10(orient) {
                return orient == 'H' ? 'horizontal' : 'vertical';
            },
            peg$c11 = "|",
            peg$c12 = {
                type: "literal",
                value: "|",
                description: "\"|\""
            },
            peg$c13 = function peg$c13() {
                return {
                    view: null
                };
            },
            peg$c14 = "[",
            peg$c15 = {
                type: "literal",
                value: "[",
                description: "\"[\""
            },
            peg$c16 = "]",
            peg$c17 = {
                type: "literal",
                value: "]",
                description: "\"]\""
            },
            peg$c18 = function peg$c18(view, predicates) {
                return extend(view, predicates ? {
                    constraints: predicates
                } : {});
            },
            peg$c19 = "-",
            peg$c20 = {
                type: "literal",
                value: "-",
                description: "\"-\""
            },
            peg$c21 = function peg$c21(predicateList) {
                return predicateList;
            },
            peg$c22 = function peg$c22() {
                return [{
                    relation: 'equ',
                    constant: 'default',
                    $parserOffset: offset()
                }];
            },
            peg$c23 = "",
            peg$c24 = function peg$c24() {
                return [{
                    relation: 'equ',
                    constant: 0,
                    $parserOffset: offset()
                }];
            },
            peg$c25 = function peg$c25(n) {
                return [{
                    relation: 'equ',
                    constant: n,
                    $parserOffset: offset()
                }];
            },
            peg$c26 = "(",
            peg$c27 = {
                type: "literal",
                value: "(",
                description: "\"(\""
            },
            peg$c28 = ",",
            peg$c29 = {
                type: "literal",
                value: ",",
                description: "\",\""
            },
            peg$c30 = ")",
            peg$c31 = {
                type: "literal",
                value: ")",
                description: "\")\""
            },
            peg$c32 = function peg$c32(p, ps) {
                return [p].concat(ps.map(function(p) {
                    return p[1];
                }));
            },
            peg$c33 = "@",
            peg$c34 = {
                type: "literal",
                value: "@",
                description: "\"@\""
            },
            peg$c35 = function peg$c35(r, o, p) {
                return extend({
                    relation: 'equ'
                }, r || {}, o, p ? p[1] : {});
            },
            peg$c36 = "==",
            peg$c37 = {
                type: "literal",
                value: "==",
                description: "\"==\""
            },
            peg$c38 = function peg$c38() {
                return {
                    relation: 'equ',
                    $parserOffset: offset()
                };
            },
            peg$c39 = "<=",
            peg$c40 = {
                type: "literal",
                value: "<=",
                description: "\"<=\""
            },
            peg$c41 = function peg$c41() {
                return {
                    relation: 'leq',
                    $parserOffset: offset()
                };
            },
            peg$c42 = ">=",
            peg$c43 = {
                type: "literal",
                value: ">=",
                description: "\">=\""
            },
            peg$c44 = function peg$c44() {
                return {
                    relation: 'geq',
                    $parserOffset: offset()
                };
            },
            peg$c45 = /^[0-9]/,
            peg$c46 = {
                type: "class",
                value: "[0-9]",
                description: "[0-9]"
            },
            peg$c47 = function peg$c47(digits) {
                return {
                    priority: parseInt(digits.join(""), 10)
                };
            },
            peg$c48 = function peg$c48(n) {
                return {
                    constant: n
                };
            },
            peg$c49 = /^[a-zA-Z_]/,
            peg$c50 = {
                type: "class",
                value: "[a-zA-Z_]",
                description: "[a-zA-Z_]"
            },
            peg$c51 = /^[a-zA-Z0-9_]/,
            peg$c52 = {
                type: "class",
                value: "[a-zA-Z0-9_]",
                description: "[a-zA-Z0-9_]"
            },
            peg$c53 = function peg$c53(f, v) {
                return {
                    view: f + v
                };
            },
            peg$c54 = ".",
            peg$c55 = {
                type: "literal",
                value: ".",
                description: "\".\""
            },
            peg$c56 = function peg$c56(digits, decimals) {
                return parseFloat(digits.concat(".").concat(decimals).join(""), 10);
            },
            peg$c57 = function peg$c57(digits) {
                return parseInt(digits.join(""), 10);
            },
            peg$currPos = 0,
            peg$reportedPos = 0,
            peg$cachedPos = 0,
            peg$cachedPosDetails = {
                line: 1,
                column: 1,
                seenCR: false
            },
            peg$maxFailPos = 0,
            peg$maxFailExpected = [],
            peg$silentFails = 0,
            peg$result;

        if ("startRule" in options) {
            if (!(options.startRule in peg$startRuleFunctions)) {
                throw new Error("Can't start parsing from rule \"" + options.startRule + "\".");
            }

            peg$startRuleFunction = peg$startRuleFunctions[options.startRule];
        }

        function text() {
            return input.substring(peg$reportedPos, peg$currPos);
        }

        function offset() {
            return peg$reportedPos;
        }

        function line() {
            return peg$computePosDetails(peg$reportedPos).line;
        }

        function column() {
            return peg$computePosDetails(peg$reportedPos).column;
        }

        function expected(description) {
            throw peg$buildException(null, [{
                type: "other",
                description: description
            }], peg$reportedPos);
        }

        function error(message) {
            throw peg$buildException(message, null, peg$reportedPos);
        }

        function peg$computePosDetails(pos) {
            function advance(details, startPos, endPos) {
                var p, ch;

                for (p = startPos; p < endPos; p++) {
                    ch = input.charAt(p);
                    if (ch === "\n") {
                        if (!details.seenCR) {
                            details.line++;
                        }
                        details.column = 1;
                        details.seenCR = false;
                    } else if (ch === "\r" || ch === '\u2028' || ch === '\u2029') {
                        details.line++;
                        details.column = 1;
                        details.seenCR = true;
                    } else {
                        details.column++;
                        details.seenCR = false;
                    }
                }
            }

            if (peg$cachedPos !== pos) {
                if (peg$cachedPos > pos) {
                    peg$cachedPos = 0;
                    peg$cachedPosDetails = {
                        line: 1,
                        column: 1,
                        seenCR: false
                    };
                }
                advance(peg$cachedPosDetails, peg$cachedPos, pos);
                peg$cachedPos = pos;
            }

            return peg$cachedPosDetails;
        }

        function peg$fail(expected) {
            if (peg$currPos < peg$maxFailPos) {
                return;
            }

            if (peg$currPos > peg$maxFailPos) {
                peg$maxFailPos = peg$currPos;
                peg$maxFailExpected = [];
            }

            peg$maxFailExpected.push(expected);
        }

        function peg$buildException(message, expected, pos) {
            function cleanupExpected(expected) {
                var i = 1;

                expected.sort(function(a, b) {
                    if (a.description < b.description) {
                        return -1;
                    } else if (a.description > b.description) {
                        return 1;
                    } else {
                        return 0;
                    }
                });

                while (i < expected.length) {
                    if (expected[i - 1] === expected[i]) {
                        expected.splice(i, 1);
                    } else {
                        i++;
                    }
                }
            }

            function buildMessage(expected, found) {
                function stringEscape(s) {
                    function hex(ch) {
                        return ch.charCodeAt(0).toString(16).toUpperCase();
                    }

                    return s.replace(/\\/g, '\\\\').replace(/"/g, '\\"').replace(/\x08/g, '\\b').replace(/\t/g, '\\t').replace(/\n/g, '\\n').replace(/\f/g, '\\f').replace(/\r/g, '\\r').replace(/[\x00-\x07\x0B\x0E\x0F]/g, function(ch) {
                        return '\\x0' + hex(ch);
                    }).replace(/[\x10-\x1F\x80-\xFF]/g, function(ch) {
                        return '\\x' + hex(ch);
                    }).replace(/[\u0180-\u0FFF]/g, function(ch) {
                        return '\\u0' + hex(ch);
                    }).replace(/[\u1080-\uFFFF]/g, function(ch) {
                        return '\\u' + hex(ch);
                    });
                }

                var expectedDescs = new Array(expected.length),
                    expectedDesc,
                    foundDesc,
                    i;

                for (i = 0; i < expected.length; i++) {
                    expectedDescs[i] = expected[i].description;
                }

                expectedDesc = expected.length > 1 ? expectedDescs.slice(0, -1).join(", ") + " or " + expectedDescs[expected.length - 1] : expectedDescs[0];

                foundDesc = found ? "\"" + stringEscape(found) + "\"" : "end of input";

                return "Expected " + expectedDesc + " but " + foundDesc + " found.";
            }

            var posDetails = peg$computePosDetails(pos),
                found = pos < input.length ? input.charAt(pos) : null;

            if (expected !== null) {
                cleanupExpected(expected);
            }

            return new SyntaxError(message !== null ? message : buildMessage(expected, found), expected, found, pos, posDetails.line, posDetails.column);
        }

        function peg$parsevisualFormatString() {
            var s0, s1, s2, s3, s4, s5, s6, s7;

            s0 = peg$currPos;
            s1 = peg$currPos;
            s2 = peg$parseorientation();
            if (s2 !== peg$FAILED) {
                if (input.charCodeAt(peg$currPos) === 58) {
                    s3 = peg$c2;
                    peg$currPos++;
                } else {
                    s3 = peg$FAILED;
                    if (peg$silentFails === 0) {
                        peg$fail(peg$c3);
                    }
                }
                if (s3 !== peg$FAILED) {
                    s2 = [s2, s3];
                    s1 = s2;
                } else {
                    peg$currPos = s1;
                    s1 = peg$c0;
                }
            } else {
                peg$currPos = s1;
                s1 = peg$c0;
            }
            if (s1 === peg$FAILED) {
                s1 = peg$c1;
            }
            if (s1 !== peg$FAILED) {
                s2 = peg$currPos;
                s3 = peg$parsesuperview();
                if (s3 !== peg$FAILED) {
                    s4 = peg$parseconnection();
                    if (s4 !== peg$FAILED) {
                        s3 = [s3, s4];
                        s2 = s3;
                    } else {
                        peg$currPos = s2;
                        s2 = peg$c0;
                    }
                } else {
                    peg$currPos = s2;
                    s2 = peg$c0;
                }
                if (s2 === peg$FAILED) {
                    s2 = peg$c1;
                }
                if (s2 !== peg$FAILED) {
                    s3 = peg$parseview();
                    if (s3 !== peg$FAILED) {
                        s4 = [];
                        s5 = peg$currPos;
                        s6 = peg$parseconnection();
                        if (s6 !== peg$FAILED) {
                            s7 = peg$parseview();
                            if (s7 !== peg$FAILED) {
                                s6 = [s6, s7];
                                s5 = s6;
                            } else {
                                peg$currPos = s5;
                                s5 = peg$c0;
                            }
                        } else {
                            peg$currPos = s5;
                            s5 = peg$c0;
                        }
                        while (s5 !== peg$FAILED) {
                            s4.push(s5);
                            s5 = peg$currPos;
                            s6 = peg$parseconnection();
                            if (s6 !== peg$FAILED) {
                                s7 = peg$parseview();
                                if (s7 !== peg$FAILED) {
                                    s6 = [s6, s7];
                                    s5 = s6;
                                } else {
                                    peg$currPos = s5;
                                    s5 = peg$c0;
                                }
                            } else {
                                peg$currPos = s5;
                                s5 = peg$c0;
                            }
                        }
                        if (s4 !== peg$FAILED) {
                            s5 = peg$currPos;
                            s6 = peg$parseconnection();
                            if (s6 !== peg$FAILED) {
                                s7 = peg$parsesuperview();
                                if (s7 !== peg$FAILED) {
                                    s6 = [s6, s7];
                                    s5 = s6;
                                } else {
                                    peg$currPos = s5;
                                    s5 = peg$c0;
                                }
                            } else {
                                peg$currPos = s5;
                                s5 = peg$c0;
                            }
                            if (s5 === peg$FAILED) {
                                s5 = peg$c1;
                            }
                            if (s5 !== peg$FAILED) {
                                peg$reportedPos = s0;
                                s1 = peg$c5(s1, s2, s3, s4, s5);
                                s0 = s1;
                            } else {
                                peg$currPos = s0;
                                s0 = peg$c0;
                            }
                        } else {
                            peg$currPos = s0;
                            s0 = peg$c0;
                        }
                    } else {
                        peg$currPos = s0;
                        s0 = peg$c0;
                    }
                } else {
                    peg$currPos = s0;
                    s0 = peg$c0;
                }
            } else {
                peg$currPos = s0;
                s0 = peg$c0;
            }

            return s0;
        }

        function peg$parseorientation() {
            var s0, s1;

            s0 = peg$currPos;
            if (input.charCodeAt(peg$currPos) === 72) {
                s1 = peg$c6;
                peg$currPos++;
            } else {
                s1 = peg$FAILED;
                if (peg$silentFails === 0) {
                    peg$fail(peg$c7);
                }
            }
            if (s1 === peg$FAILED) {
                if (input.charCodeAt(peg$currPos) === 86) {
                    s1 = peg$c8;
                    peg$currPos++;
                } else {
                    s1 = peg$FAILED;
                    if (peg$silentFails === 0) {
                        peg$fail(peg$c9);
                    }
                }
            }
            if (s1 !== peg$FAILED) {
                peg$reportedPos = s0;
                s1 = peg$c10(s1);
            }
            s0 = s1;

            return s0;
        }

        function peg$parsesuperview() {
            var s0, s1;

            s0 = peg$currPos;
            if (input.charCodeAt(peg$currPos) === 124) {
                s1 = peg$c11;
                peg$currPos++;
            } else {
                s1 = peg$FAILED;
                if (peg$silentFails === 0) {
                    peg$fail(peg$c12);
                }
            }
            if (s1 !== peg$FAILED) {
                peg$reportedPos = s0;
                s1 = peg$c13();
            }
            s0 = s1;

            return s0;
        }

        function peg$parseview() {
            var s0, s1, s2, s3, s4;

            s0 = peg$currPos;
            if (input.charCodeAt(peg$currPos) === 91) {
                s1 = peg$c14;
                peg$currPos++;
            } else {
                s1 = peg$FAILED;
                if (peg$silentFails === 0) {
                    peg$fail(peg$c15);
                }
            }
            if (s1 !== peg$FAILED) {
                s2 = peg$parseviewName();
                if (s2 !== peg$FAILED) {
                    s3 = peg$parsepredicateListWithParens();
                    if (s3 === peg$FAILED) {
                        s3 = peg$c1;
                    }
                    if (s3 !== peg$FAILED) {
                        if (input.charCodeAt(peg$currPos) === 93) {
                            s4 = peg$c16;
                            peg$currPos++;
                        } else {
                            s4 = peg$FAILED;
                            if (peg$silentFails === 0) {
                                peg$fail(peg$c17);
                            }
                        }
                        if (s4 !== peg$FAILED) {
                            peg$reportedPos = s0;
                            s1 = peg$c18(s2, s3);
                            s0 = s1;
                        } else {
                            peg$currPos = s0;
                            s0 = peg$c0;
                        }
                    } else {
                        peg$currPos = s0;
                        s0 = peg$c0;
                    }
                } else {
                    peg$currPos = s0;
                    s0 = peg$c0;
                }
            } else {
                peg$currPos = s0;
                s0 = peg$c0;
            }

            return s0;
        }

        function peg$parseconnection() {
            var s0, s1, s2, s3;

            s0 = peg$currPos;
            if (input.charCodeAt(peg$currPos) === 45) {
                s1 = peg$c19;
                peg$currPos++;
            } else {
                s1 = peg$FAILED;
                if (peg$silentFails === 0) {
                    peg$fail(peg$c20);
                }
            }
            if (s1 !== peg$FAILED) {
                s2 = peg$parsepredicateList();
                if (s2 !== peg$FAILED) {
                    if (input.charCodeAt(peg$currPos) === 45) {
                        s3 = peg$c19;
                        peg$currPos++;
                    } else {
                        s3 = peg$FAILED;
                        if (peg$silentFails === 0) {
                            peg$fail(peg$c20);
                        }
                    }
                    if (s3 !== peg$FAILED) {
                        peg$reportedPos = s0;
                        s1 = peg$c21(s2);
                        s0 = s1;
                    } else {
                        peg$currPos = s0;
                        s0 = peg$c0;
                    }
                } else {
                    peg$currPos = s0;
                    s0 = peg$c0;
                }
            } else {
                peg$currPos = s0;
                s0 = peg$c0;
            }
            if (s0 === peg$FAILED) {
                s0 = peg$currPos;
                if (input.charCodeAt(peg$currPos) === 45) {
                    s1 = peg$c19;
                    peg$currPos++;
                } else {
                    s1 = peg$FAILED;
                    if (peg$silentFails === 0) {
                        peg$fail(peg$c20);
                    }
                }
                if (s1 !== peg$FAILED) {
                    peg$reportedPos = s0;
                    s1 = peg$c22();
                }
                s0 = s1;
                if (s0 === peg$FAILED) {
                    s0 = peg$currPos;
                    s1 = peg$c23;
                    if (s1 !== peg$FAILED) {
                        peg$reportedPos = s0;
                        s1 = peg$c24();
                    }
                    s0 = s1;
                }
            }

            return s0;
        }

        function peg$parsepredicateList() {
            var s0;

            s0 = peg$parsesimplePredicate();
            if (s0 === peg$FAILED) {
                s0 = peg$parsepredicateListWithParens();
            }

            return s0;
        }

        function peg$parsesimplePredicate() {
            var s0, s1;

            s0 = peg$currPos;
            s1 = peg$parsenumber();
            if (s1 !== peg$FAILED) {
                peg$reportedPos = s0;
                s1 = peg$c25(s1);
            }
            s0 = s1;

            return s0;
        }

        function peg$parsepredicateListWithParens() {
            var s0, s1, s2, s3, s4, s5, s6;

            s0 = peg$currPos;
            if (input.charCodeAt(peg$currPos) === 40) {
                s1 = peg$c26;
                peg$currPos++;
            } else {
                s1 = peg$FAILED;
                if (peg$silentFails === 0) {
                    peg$fail(peg$c27);
                }
            }
            if (s1 !== peg$FAILED) {
                s2 = peg$parsepredicate();
                if (s2 !== peg$FAILED) {
                    s3 = [];
                    s4 = peg$currPos;
                    if (input.charCodeAt(peg$currPos) === 44) {
                        s5 = peg$c28;
                        peg$currPos++;
                    } else {
                        s5 = peg$FAILED;
                        if (peg$silentFails === 0) {
                            peg$fail(peg$c29);
                        }
                    }
                    if (s5 !== peg$FAILED) {
                        s6 = peg$parsepredicate();
                        if (s6 !== peg$FAILED) {
                            s5 = [s5, s6];
                            s4 = s5;
                        } else {
                            peg$currPos = s4;
                            s4 = peg$c0;
                        }
                    } else {
                        peg$currPos = s4;
                        s4 = peg$c0;
                    }
                    while (s4 !== peg$FAILED) {
                        s3.push(s4);
                        s4 = peg$currPos;
                        if (input.charCodeAt(peg$currPos) === 44) {
                            s5 = peg$c28;
                            peg$currPos++;
                        } else {
                            s5 = peg$FAILED;
                            if (peg$silentFails === 0) {
                                peg$fail(peg$c29);
                            }
                        }
                        if (s5 !== peg$FAILED) {
                            s6 = peg$parsepredicate();
                            if (s6 !== peg$FAILED) {
                                s5 = [s5, s6];
                                s4 = s5;
                            } else {
                                peg$currPos = s4;
                                s4 = peg$c0;
                            }
                        } else {
                            peg$currPos = s4;
                            s4 = peg$c0;
                        }
                    }
                    if (s3 !== peg$FAILED) {
                        if (input.charCodeAt(peg$currPos) === 41) {
                            s4 = peg$c30;
                            peg$currPos++;
                        } else {
                            s4 = peg$FAILED;
                            if (peg$silentFails === 0) {
                                peg$fail(peg$c31);
                            }
                        }
                        if (s4 !== peg$FAILED) {
                            peg$reportedPos = s0;
                            s1 = peg$c32(s2, s3);
                            s0 = s1;
                        } else {
                            peg$currPos = s0;
                            s0 = peg$c0;
                        }
                    } else {
                        peg$currPos = s0;
                        s0 = peg$c0;
                    }
                } else {
                    peg$currPos = s0;
                    s0 = peg$c0;
                }
            } else {
                peg$currPos = s0;
                s0 = peg$c0;
            }

            return s0;
        }

        function peg$parsepredicate() {
            var s0, s1, s2, s3, s4, s5;

            s0 = peg$currPos;
            s1 = peg$parserelation();
            if (s1 === peg$FAILED) {
                s1 = peg$c1;
            }
            if (s1 !== peg$FAILED) {
                s2 = peg$parseobjectOfPredicate();
                if (s2 !== peg$FAILED) {
                    s3 = peg$currPos;
                    if (input.charCodeAt(peg$currPos) === 64) {
                        s4 = peg$c33;
                        peg$currPos++;
                    } else {
                        s4 = peg$FAILED;
                        if (peg$silentFails === 0) {
                            peg$fail(peg$c34);
                        }
                    }
                    if (s4 !== peg$FAILED) {
                        s5 = peg$parsepriority();
                        if (s5 !== peg$FAILED) {
                            s4 = [s4, s5];
                            s3 = s4;
                        } else {
                            peg$currPos = s3;
                            s3 = peg$c0;
                        }
                    } else {
                        peg$currPos = s3;
                        s3 = peg$c0;
                    }
                    if (s3 === peg$FAILED) {
                        s3 = peg$c1;
                    }
                    if (s3 !== peg$FAILED) {
                        peg$reportedPos = s0;
                        s1 = peg$c35(s1, s2, s3);
                        s0 = s1;
                    } else {
                        peg$currPos = s0;
                        s0 = peg$c0;
                    }
                } else {
                    peg$currPos = s0;
                    s0 = peg$c0;
                }
            } else {
                peg$currPos = s0;
                s0 = peg$c0;
            }

            return s0;
        }

        function peg$parserelation() {
            var s0, s1;

            s0 = peg$currPos;
            if (input.substr(peg$currPos, 2) === peg$c36) {
                s1 = peg$c36;
                peg$currPos += 2;
            } else {
                s1 = peg$FAILED;
                if (peg$silentFails === 0) {
                    peg$fail(peg$c37);
                }
            }
            if (s1 !== peg$FAILED) {
                peg$reportedPos = s0;
                s1 = peg$c38();
            }
            s0 = s1;
            if (s0 === peg$FAILED) {
                s0 = peg$currPos;
                if (input.substr(peg$currPos, 2) === peg$c39) {
                    s1 = peg$c39;
                    peg$currPos += 2;
                } else {
                    s1 = peg$FAILED;
                    if (peg$silentFails === 0) {
                        peg$fail(peg$c40);
                    }
                }
                if (s1 !== peg$FAILED) {
                    peg$reportedPos = s0;
                    s1 = peg$c41();
                }
                s0 = s1;
                if (s0 === peg$FAILED) {
                    s0 = peg$currPos;
                    if (input.substr(peg$currPos, 2) === peg$c42) {
                        s1 = peg$c42;
                        peg$currPos += 2;
                    } else {
                        s1 = peg$FAILED;
                        if (peg$silentFails === 0) {
                            peg$fail(peg$c43);
                        }
                    }
                    if (s1 !== peg$FAILED) {
                        peg$reportedPos = s0;
                        s1 = peg$c44();
                    }
                    s0 = s1;
                }
            }

            return s0;
        }

        function peg$parseobjectOfPredicate() {
            var s0;

            s0 = peg$parseconstant();
            if (s0 === peg$FAILED) {
                s0 = peg$parseviewName();
            }

            return s0;
        }

        function peg$parsepriority() {
            var s0, s1, s2;

            s0 = peg$currPos;
            s1 = [];
            if (peg$c45.test(input.charAt(peg$currPos))) {
                s2 = input.charAt(peg$currPos);
                peg$currPos++;
            } else {
                s2 = peg$FAILED;
                if (peg$silentFails === 0) {
                    peg$fail(peg$c46);
                }
            }
            if (s2 !== peg$FAILED) {
                while (s2 !== peg$FAILED) {
                    s1.push(s2);
                    if (peg$c45.test(input.charAt(peg$currPos))) {
                        s2 = input.charAt(peg$currPos);
                        peg$currPos++;
                    } else {
                        s2 = peg$FAILED;
                        if (peg$silentFails === 0) {
                            peg$fail(peg$c46);
                        }
                    }
                }
            } else {
                s1 = peg$c0;
            }
            if (s1 !== peg$FAILED) {
                peg$reportedPos = s0;
                s1 = peg$c47(s1);
            }
            s0 = s1;

            return s0;
        }

        function peg$parseconstant() {
            var s0, s1;

            s0 = peg$currPos;
            s1 = peg$parsenumber();
            if (s1 !== peg$FAILED) {
                peg$reportedPos = s0;
                s1 = peg$c48(s1);
            }
            s0 = s1;

            return s0;
        }

        function peg$parseviewName() {
            var s0, s1, s2, s3, s4;

            s0 = peg$currPos;
            s1 = peg$currPos;
            s2 = [];
            if (peg$c49.test(input.charAt(peg$currPos))) {
                s3 = input.charAt(peg$currPos);
                peg$currPos++;
            } else {
                s3 = peg$FAILED;
                if (peg$silentFails === 0) {
                    peg$fail(peg$c50);
                }
            }
            if (s3 !== peg$FAILED) {
                while (s3 !== peg$FAILED) {
                    s2.push(s3);
                    if (peg$c49.test(input.charAt(peg$currPos))) {
                        s3 = input.charAt(peg$currPos);
                        peg$currPos++;
                    } else {
                        s3 = peg$FAILED;
                        if (peg$silentFails === 0) {
                            peg$fail(peg$c50);
                        }
                    }
                }
            } else {
                s2 = peg$c0;
            }
            if (s2 !== peg$FAILED) {
                s2 = input.substring(s1, peg$currPos);
            }
            s1 = s2;
            if (s1 !== peg$FAILED) {
                s2 = peg$currPos;
                s3 = [];
                if (peg$c51.test(input.charAt(peg$currPos))) {
                    s4 = input.charAt(peg$currPos);
                    peg$currPos++;
                } else {
                    s4 = peg$FAILED;
                    if (peg$silentFails === 0) {
                        peg$fail(peg$c52);
                    }
                }
                while (s4 !== peg$FAILED) {
                    s3.push(s4);
                    if (peg$c51.test(input.charAt(peg$currPos))) {
                        s4 = input.charAt(peg$currPos);
                        peg$currPos++;
                    } else {
                        s4 = peg$FAILED;
                        if (peg$silentFails === 0) {
                            peg$fail(peg$c52);
                        }
                    }
                }
                if (s3 !== peg$FAILED) {
                    s3 = input.substring(s2, peg$currPos);
                }
                s2 = s3;
                if (s2 !== peg$FAILED) {
                    peg$reportedPos = s0;
                    s1 = peg$c53(s1, s2);
                    s0 = s1;
                } else {
                    peg$currPos = s0;
                    s0 = peg$c0;
                }
            } else {
                peg$currPos = s0;
                s0 = peg$c0;
            }

            return s0;
        }

        function peg$parsenumber() {
            var s0, s1, s2, s3, s4;

            s0 = peg$currPos;
            s1 = [];
            if (peg$c45.test(input.charAt(peg$currPos))) {
                s2 = input.charAt(peg$currPos);
                peg$currPos++;
            } else {
                s2 = peg$FAILED;
                if (peg$silentFails === 0) {
                    peg$fail(peg$c46);
                }
            }
            if (s2 !== peg$FAILED) {
                while (s2 !== peg$FAILED) {
                    s1.push(s2);
                    if (peg$c45.test(input.charAt(peg$currPos))) {
                        s2 = input.charAt(peg$currPos);
                        peg$currPos++;
                    } else {
                        s2 = peg$FAILED;
                        if (peg$silentFails === 0) {
                            peg$fail(peg$c46);
                        }
                    }
                }
            } else {
                s1 = peg$c0;
            }
            if (s1 !== peg$FAILED) {
                if (input.charCodeAt(peg$currPos) === 46) {
                    s2 = peg$c54;
                    peg$currPos++;
                } else {
                    s2 = peg$FAILED;
                    if (peg$silentFails === 0) {
                        peg$fail(peg$c55);
                    }
                }
                if (s2 !== peg$FAILED) {
                    s3 = [];
                    if (peg$c45.test(input.charAt(peg$currPos))) {
                        s4 = input.charAt(peg$currPos);
                        peg$currPos++;
                    } else {
                        s4 = peg$FAILED;
                        if (peg$silentFails === 0) {
                            peg$fail(peg$c46);
                        }
                    }
                    if (s4 !== peg$FAILED) {
                        while (s4 !== peg$FAILED) {
                            s3.push(s4);
                            if (peg$c45.test(input.charAt(peg$currPos))) {
                                s4 = input.charAt(peg$currPos);
                                peg$currPos++;
                            } else {
                                s4 = peg$FAILED;
                                if (peg$silentFails === 0) {
                                    peg$fail(peg$c46);
                                }
                            }
                        }
                    } else {
                        s3 = peg$c0;
                    }
                    if (s3 !== peg$FAILED) {
                        peg$reportedPos = s0;
                        s1 = peg$c56(s1, s3);
                        s0 = s1;
                    } else {
                        peg$currPos = s0;
                        s0 = peg$c0;
                    }
                } else {
                    peg$currPos = s0;
                    s0 = peg$c0;
                }
            } else {
                peg$currPos = s0;
                s0 = peg$c0;
            }
            if (s0 === peg$FAILED) {
                s0 = peg$currPos;
                s1 = [];
                if (peg$c45.test(input.charAt(peg$currPos))) {
                    s2 = input.charAt(peg$currPos);
                    peg$currPos++;
                } else {
                    s2 = peg$FAILED;
                    if (peg$silentFails === 0) {
                        peg$fail(peg$c46);
                    }
                }
                if (s2 !== peg$FAILED) {
                    while (s2 !== peg$FAILED) {
                        s1.push(s2);
                        if (peg$c45.test(input.charAt(peg$currPos))) {
                            s2 = input.charAt(peg$currPos);
                            peg$currPos++;
                        } else {
                            s2 = peg$FAILED;
                            if (peg$silentFails === 0) {
                                peg$fail(peg$c46);
                            }
                        }
                    }
                } else {
                    s1 = peg$c0;
                }
                if (s1 !== peg$FAILED) {
                    peg$reportedPos = s0;
                    s1 = peg$c57(s1);
                }
                s0 = s1;
            }

            return s0;
        }

        function extend(dst) {
            for (var i = 1; i < arguments.length; i++) {
                for (var k in arguments[i]) {
                    dst[k] = arguments[i][k];
                }
            }
            return dst;
        }

        peg$result = peg$startRuleFunction();

        if (peg$result !== peg$FAILED && peg$currPos === input.length) {
            return peg$result;
        } else {
            if (peg$result !== peg$FAILED && peg$currPos < input.length) {
                peg$fail({
                    type: "end",
                    description: "end of input"
                });
            }

            throw peg$buildException(null, peg$maxFailExpected, peg$maxFailPos);
        }
    }

    return {
        SyntaxError: SyntaxError,
        parse: parse
    };
})();

var parserExt = (function() {
    /*
     * Generated by PEG.js 0.8.0.
     *
     * http://pegjs.majda.cz/
     */

    function peg$subclass(child, parent) {
        function ctor() {
            this.constructor = child;
        }
        ctor.prototype = parent.prototype;
        child.prototype = new ctor();
    }

    function SyntaxError(message, expected, found, offset, line, column) {
        this.message = message;
        this.expected = expected;
        this.found = found;
        this.offset = offset;
        this.line = line;
        this.column = column;

        this.name = "SyntaxError";
    }

    peg$subclass(SyntaxError, Error);

    function parse(input) {
        var options = arguments.length > 1 ? arguments[1] : {},
            peg$FAILED = {},
            peg$startRuleFunctions = {
                visualFormatString: peg$parsevisualFormatString
            },
            peg$startRuleFunction = peg$parsevisualFormatString,
            peg$c0 = peg$FAILED,
            peg$c1 = null,
            peg$c2 = ":",
            peg$c3 = {
                type: "literal",
                value: ":",
                description: "\":\""
            },
            peg$c4 = [],
            peg$c5 = function peg$c5(o, superto, view, views, tosuper, comments) {
                return {
                    orientation: o ? o[0] : 'horizontal',
                    cascade: (superto || []).concat(view, [].concat.apply([], views), tosuper || [])
                };
            },
            peg$c6 = "HV",
            peg$c7 = {
                type: "literal",
                value: "HV",
                description: "\"HV\""
            },
            peg$c8 = function peg$c8() {
                return 'horzvert';
            },
            peg$c9 = "H",
            peg$c10 = {
                type: "literal",
                value: "H",
                description: "\"H\""
            },
            peg$c11 = function peg$c11() {
                return 'horizontal';
            },
            peg$c12 = "V",
            peg$c13 = {
                type: "literal",
                value: "V",
                description: "\"V\""
            },
            peg$c14 = function peg$c14() {
                return 'vertical';
            },
            peg$c15 = "Z",
            peg$c16 = {
                type: "literal",
                value: "Z",
                description: "\"Z\""
            },
            peg$c17 = function peg$c17() {
                return 'zIndex';
            },
            peg$c18 = " ",
            peg$c19 = {
                type: "literal",
                value: " ",
                description: "\" \""
            },
            peg$c20 = "//",
            peg$c21 = {
                type: "literal",
                value: "//",
                description: "\"//\""
            },
            peg$c22 = {
                type: "any",
                description: "any character"
            },
            peg$c23 = "|",
            peg$c24 = {
                type: "literal",
                value: "|",
                description: "\"|\""
            },
            peg$c25 = function peg$c25() {
                return {
                    view: null
                };
            },
            peg$c26 = "[",
            peg$c27 = {
                type: "literal",
                value: "[",
                description: "\"[\""
            },
            peg$c28 = ",",
            peg$c29 = {
                type: "literal",
                value: ",",
                description: "\",\""
            },
            peg$c30 = "]",
            peg$c31 = {
                type: "literal",
                value: "]",
                description: "\"]\""
            },
            peg$c32 = function peg$c32(view, views) {
                return views.length ? [view].concat([].concat.apply([], views)) : view;
            },
            peg$c33 = function peg$c33(view, predicates, cascadedViews) {
                return extend(extend(view, predicates ? {
                    constraints: predicates
                } : {}), cascadedViews ? {
                    cascade: cascadedViews
                } : {});
            },
            peg$c34 = function peg$c34(views, connection) {
                return [].concat([].concat.apply([], views), [connection]);
            },
            peg$c35 = "->",
            peg$c36 = {
                type: "literal",
                value: "->",
                description: "\"->\""
            },
            peg$c37 = function peg$c37() {
                return [{
                    relation: 'none'
                }];
            },
            peg$c38 = "-",
            peg$c39 = {
                type: "literal",
                value: "-",
                description: "\"-\""
            },
            peg$c40 = function peg$c40(predicateList) {
                return predicateList;
            },
            peg$c41 = function peg$c41() {
                return [{
                    relation: 'equ',
                    constant: 'default'
                }];
            },
            peg$c42 = "~",
            peg$c43 = {
                type: "literal",
                value: "~",
                description: "\"~\""
            },
            peg$c44 = function peg$c44() {
                return [{
                    relation: 'equ',
                    equalSpacing: true
                }];
            },
            peg$c45 = "",
            peg$c46 = function peg$c46() {
                return [{
                    relation: 'equ',
                    constant: 0
                }];
            },
            peg$c47 = function peg$c47(p) {
                return [{
                    relation: 'equ',
                    multiplier: p.multiplier
                }];
            },
            peg$c48 = function peg$c48(n) {
                return [{
                    relation: 'equ',
                    constant: n
                }];
            },
            peg$c49 = "(",
            peg$c50 = {
                type: "literal",
                value: "(",
                description: "\"(\""
            },
            peg$c51 = ")",
            peg$c52 = {
                type: "literal",
                value: ")",
                description: "\")\""
            },
            peg$c53 = function peg$c53(p, ps) {
                return [p].concat(ps.map(function(p) {
                    return p[1];
                }));
            },
            peg$c54 = "@",
            peg$c55 = {
                type: "literal",
                value: "@",
                description: "\"@\""
            },
            peg$c56 = function peg$c56(r, o, p) {
                return extend({
                    relation: 'equ'
                }, r || {}, o, p ? p[1] : {});
            },
            peg$c57 = function peg$c57(r, o, p) {
                return extend({
                    relation: 'equ',
                    equalSpacing: true
                }, r || {}, o, p ? p[1] : {});
            },
            peg$c58 = "==",
            peg$c59 = {
                type: "literal",
                value: "==",
                description: "\"==\""
            },
            peg$c60 = function peg$c60() {
                return {
                    relation: 'equ'
                };
            },
            peg$c61 = "<=",
            peg$c62 = {
                type: "literal",
                value: "<=",
                description: "\"<=\""
            },
            peg$c63 = function peg$c63() {
                return {
                    relation: 'leq'
                };
            },
            peg$c64 = ">=",
            peg$c65 = {
                type: "literal",
                value: ">=",
                description: "\">=\""
            },
            peg$c66 = function peg$c66() {
                return {
                    relation: 'geq'
                };
            },
            peg$c67 = /^[0-9]/,
            peg$c68 = {
                type: "class",
                value: "[0-9]",
                description: "[0-9]"
            },
            peg$c69 = function peg$c69(digits) {
                return {
                    priority: parseInt(digits.join(""), 10)
                };
            },
            peg$c70 = function peg$c70(n) {
                return {
                    constant: n
                };
            },
            peg$c71 = "%",
            peg$c72 = {
                type: "literal",
                value: "%",
                description: "\"%\""
            },
            peg$c73 = function peg$c73(n) {
                return {
                    view: null,
                    multiplier: n / 100
                };
            },
            peg$c74 = function peg$c74(vn, a, m, c) {
                return {
                    view: vn.view,
                    attribute: a ? a : undefined,
                    multiplier: m ? m : 1,
                    constant: c ? c : undefined
                };
            },
            peg$c75 = ".left",
            peg$c76 = {
                type: "literal",
                value: ".left",
                description: "\".left\""
            },
            peg$c77 = function peg$c77() {
                return 'left';
            },
            peg$c78 = ".right",
            peg$c79 = {
                type: "literal",
                value: ".right",
                description: "\".right\""
            },
            peg$c80 = function peg$c80() {
                return 'right';
            },
            peg$c81 = ".top",
            peg$c82 = {
                type: "literal",
                value: ".top",
                description: "\".top\""
            },
            peg$c83 = function peg$c83() {
                return 'top';
            },
            peg$c84 = ".bottom",
            peg$c85 = {
                type: "literal",
                value: ".bottom",
                description: "\".bottom\""
            },
            peg$c86 = function peg$c86() {
                return 'bottom';
            },
            peg$c87 = ".width",
            peg$c88 = {
                type: "literal",
                value: ".width",
                description: "\".width\""
            },
            peg$c89 = function peg$c89() {
                return 'width';
            },
            peg$c90 = ".height",
            peg$c91 = {
                type: "literal",
                value: ".height",
                description: "\".height\""
            },
            peg$c92 = function peg$c92() {
                return 'height';
            },
            peg$c93 = ".centerX",
            peg$c94 = {
                type: "literal",
                value: ".centerX",
                description: "\".centerX\""
            },
            peg$c95 = function peg$c95() {
                return 'centerX';
            },
            peg$c96 = ".centerY",
            peg$c97 = {
                type: "literal",
                value: ".centerY",
                description: "\".centerY\""
            },
            peg$c98 = function peg$c98() {
                return 'centerY';
            },
            peg$c99 = "/",
            peg$c100 = {
                type: "literal",
                value: "/",
                description: "\"/\""
            },
            peg$c101 = function peg$c101(n) {
                return 1 / n;
            },
            peg$c102 = "*",
            peg$c103 = {
                type: "literal",
                value: "*",
                description: "\"*\""
            },
            peg$c104 = function peg$c104(n) {
                return n;
            },
            peg$c105 = function peg$c105(n) {
                return -n;
            },
            peg$c106 = "+",
            peg$c107 = {
                type: "literal",
                value: "+",
                description: "\"+\""
            },
            peg$c108 = /^[a-zA-Z_]/,
            peg$c109 = {
                type: "class",
                value: "[a-zA-Z_]",
                description: "[a-zA-Z_]"
            },
            peg$c110 = /^[a-zA-Z0-9_]/,
            peg$c111 = {
                type: "class",
                value: "[a-zA-Z0-9_]",
                description: "[a-zA-Z0-9_]"
            },
            peg$c112 = function peg$c112(f, v, r) {
                return {
                    view: f + v,
                    range: r,
                    $parserOffset: offset()
                };
            },
            peg$c113 = function peg$c113(f, v) {
                return {
                    view: f + v,
                    $parserOffset: offset()
                };
            },
            peg$c114 = "..",
            peg$c115 = {
                type: "literal",
                value: "..",
                description: "\"..\""
            },
            peg$c116 = function peg$c116(d) {
                return parseInt(d);
            },
            peg$c117 = ".",
            peg$c118 = {
                type: "literal",
                value: ".",
                description: "\".\""
            },
            peg$c119 = function peg$c119(digits, decimals) {
                return parseFloat(digits.concat(".").concat(decimals).join(""), 10);
            },
            peg$c120 = function peg$c120(digits) {
                return parseInt(digits.join(""), 10);
            },
            peg$currPos = 0,
            peg$reportedPos = 0,
            peg$cachedPos = 0,
            peg$cachedPosDetails = {
                line: 1,
                column: 1,
                seenCR: false
            },
            peg$maxFailPos = 0,
            peg$maxFailExpected = [],
            peg$silentFails = 0,
            peg$result;

        if ("startRule" in options) {
            if (!(options.startRule in peg$startRuleFunctions)) {
                throw new Error("Can't start parsing from rule \"" + options.startRule + "\".");
            }

            peg$startRuleFunction = peg$startRuleFunctions[options.startRule];
        }

        function text() {
            return input.substring(peg$reportedPos, peg$currPos);
        }

        function offset() {
            return peg$reportedPos;
        }

        function line() {
            return peg$computePosDetails(peg$reportedPos).line;
        }

        function column() {
            return peg$computePosDetails(peg$reportedPos).column;
        }

        function expected(description) {
            throw peg$buildException(null, [{
                type: "other",
                description: description
            }], peg$reportedPos);
        }

        function error(message) {
            throw peg$buildException(message, null, peg$reportedPos);
        }

        function peg$computePosDetails(pos) {
            function advance(details, startPos, endPos) {
                var p, ch;

                for (p = startPos; p < endPos; p++) {
                    ch = input.charAt(p);
                    if (ch === "\n") {
                        if (!details.seenCR) {
                            details.line++;
                        }
                        details.column = 1;
                        details.seenCR = false;
                    } else if (ch === "\r" || ch === '\u2028' || ch === '\u2029') {
                        details.line++;
                        details.column = 1;
                        details.seenCR = true;
                    } else {
                        details.column++;
                        details.seenCR = false;
                    }
                }
            }

            if (peg$cachedPos !== pos) {
                if (peg$cachedPos > pos) {
                    peg$cachedPos = 0;
                    peg$cachedPosDetails = {
                        line: 1,
                        column: 1,
                        seenCR: false
                    };
                }
                advance(peg$cachedPosDetails, peg$cachedPos, pos);
                peg$cachedPos = pos;
            }

            return peg$cachedPosDetails;
        }

        function peg$fail(expected) {
            if (peg$currPos < peg$maxFailPos) {
                return;
            }

            if (peg$currPos > peg$maxFailPos) {
                peg$maxFailPos = peg$currPos;
                peg$maxFailExpected = [];
            }

            peg$maxFailExpected.push(expected);
        }

        function peg$buildException(message, expected, pos) {
            function cleanupExpected(expected) {
                var i = 1;

                expected.sort(function(a, b) {
                    if (a.description < b.description) {
                        return -1;
                    } else if (a.description > b.description) {
                        return 1;
                    } else {
                        return 0;
                    }
                });

                while (i < expected.length) {
                    if (expected[i - 1] === expected[i]) {
                        expected.splice(i, 1);
                    } else {
                        i++;
                    }
                }
            }

            function buildMessage(expected, found) {
                function stringEscape(s) {
                    function hex(ch) {
                        return ch.charCodeAt(0).toString(16).toUpperCase();
                    }

                    return s.replace(/\\/g, '\\\\').replace(/"/g, '\\"').replace(/\x08/g, '\\b').replace(/\t/g, '\\t').replace(/\n/g, '\\n').replace(/\f/g, '\\f').replace(/\r/g, '\\r').replace(/[\x00-\x07\x0B\x0E\x0F]/g, function(ch) {
                        return '\\x0' + hex(ch);
                    }).replace(/[\x10-\x1F\x80-\xFF]/g, function(ch) {
                        return '\\x' + hex(ch);
                    }).replace(/[\u0180-\u0FFF]/g, function(ch) {
                        return '\\u0' + hex(ch);
                    }).replace(/[\u1080-\uFFFF]/g, function(ch) {
                        return '\\u' + hex(ch);
                    });
                }

                var expectedDescs = new Array(expected.length),
                    expectedDesc,
                    foundDesc,
                    i;

                for (i = 0; i < expected.length; i++) {
                    expectedDescs[i] = expected[i].description;
                }

                expectedDesc = expected.length > 1 ? expectedDescs.slice(0, -1).join(", ") + " or " + expectedDescs[expected.length - 1] : expectedDescs[0];

                foundDesc = found ? "\"" + stringEscape(found) + "\"" : "end of input";

                return "Expected " + expectedDesc + " but " + foundDesc + " found.";
            }

            var posDetails = peg$computePosDetails(pos),
                found = pos < input.length ? input.charAt(pos) : null;

            if (expected !== null) {
                cleanupExpected(expected);
            }

            return new SyntaxError(message !== null ? message : buildMessage(expected, found), expected, found, pos, posDetails.line, posDetails.column);
        }

        function peg$parsevisualFormatString() {
            var s0, s1, s2, s3, s4, s5, s6, s7;

            s0 = peg$currPos;
            s1 = peg$currPos;
            s2 = peg$parseorientation();
            if (s2 !== peg$FAILED) {
                if (input.charCodeAt(peg$currPos) === 58) {
                    s3 = peg$c2;
                    peg$currPos++;
                } else {
                    s3 = peg$FAILED;
                    if (peg$silentFails === 0) {
                        peg$fail(peg$c3);
                    }
                }
                if (s3 !== peg$FAILED) {
                    s2 = [s2, s3];
                    s1 = s2;
                } else {
                    peg$currPos = s1;
                    s1 = peg$c0;
                }
            } else {
                peg$currPos = s1;
                s1 = peg$c0;
            }
            if (s1 === peg$FAILED) {
                s1 = peg$c1;
            }
            if (s1 !== peg$FAILED) {
                s2 = peg$currPos;
                s3 = peg$parsesuperview();
                if (s3 !== peg$FAILED) {
                    s4 = peg$parseconnection();
                    if (s4 !== peg$FAILED) {
                        s3 = [s3, s4];
                        s2 = s3;
                    } else {
                        peg$currPos = s2;
                        s2 = peg$c0;
                    }
                } else {
                    peg$currPos = s2;
                    s2 = peg$c0;
                }
                if (s2 === peg$FAILED) {
                    s2 = peg$c1;
                }
                if (s2 !== peg$FAILED) {
                    s3 = peg$parseviewGroup();
                    if (s3 !== peg$FAILED) {
                        s4 = [];
                        s5 = peg$currPos;
                        s6 = peg$parseconnection();
                        if (s6 !== peg$FAILED) {
                            s7 = peg$parseviewGroup();
                            if (s7 !== peg$FAILED) {
                                s6 = [s6, s7];
                                s5 = s6;
                            } else {
                                peg$currPos = s5;
                                s5 = peg$c0;
                            }
                        } else {
                            peg$currPos = s5;
                            s5 = peg$c0;
                        }
                        while (s5 !== peg$FAILED) {
                            s4.push(s5);
                            s5 = peg$currPos;
                            s6 = peg$parseconnection();
                            if (s6 !== peg$FAILED) {
                                s7 = peg$parseviewGroup();
                                if (s7 !== peg$FAILED) {
                                    s6 = [s6, s7];
                                    s5 = s6;
                                } else {
                                    peg$currPos = s5;
                                    s5 = peg$c0;
                                }
                            } else {
                                peg$currPos = s5;
                                s5 = peg$c0;
                            }
                        }
                        if (s4 !== peg$FAILED) {
                            s5 = peg$currPos;
                            s6 = peg$parseconnection();
                            if (s6 !== peg$FAILED) {
                                s7 = peg$parsesuperview();
                                if (s7 !== peg$FAILED) {
                                    s6 = [s6, s7];
                                    s5 = s6;
                                } else {
                                    peg$currPos = s5;
                                    s5 = peg$c0;
                                }
                            } else {
                                peg$currPos = s5;
                                s5 = peg$c0;
                            }
                            if (s5 === peg$FAILED) {
                                s5 = peg$c1;
                            }
                            if (s5 !== peg$FAILED) {
                                s6 = peg$parsecomments();
                                if (s6 === peg$FAILED) {
                                    s6 = peg$c1;
                                }
                                if (s6 !== peg$FAILED) {
                                    peg$reportedPos = s0;
                                    s1 = peg$c5(s1, s2, s3, s4, s5, s6);
                                    s0 = s1;
                                } else {
                                    peg$currPos = s0;
                                    s0 = peg$c0;
                                }
                            } else {
                                peg$currPos = s0;
                                s0 = peg$c0;
                            }
                        } else {
                            peg$currPos = s0;
                            s0 = peg$c0;
                        }
                    } else {
                        peg$currPos = s0;
                        s0 = peg$c0;
                    }
                } else {
                    peg$currPos = s0;
                    s0 = peg$c0;
                }
            } else {
                peg$currPos = s0;
                s0 = peg$c0;
            }

            return s0;
        }

        function peg$parseorientation() {
            var s0, s1;

            s0 = peg$currPos;
            if (input.substr(peg$currPos, 2) === peg$c6) {
                s1 = peg$c6;
                peg$currPos += 2;
            } else {
                s1 = peg$FAILED;
                if (peg$silentFails === 0) {
                    peg$fail(peg$c7);
                }
            }
            if (s1 !== peg$FAILED) {
                peg$reportedPos = s0;
                s1 = peg$c8();
            }
            s0 = s1;
            if (s0 === peg$FAILED) {
                s0 = peg$currPos;
                if (input.charCodeAt(peg$currPos) === 72) {
                    s1 = peg$c9;
                    peg$currPos++;
                } else {
                    s1 = peg$FAILED;
                    if (peg$silentFails === 0) {
                        peg$fail(peg$c10);
                    }
                }
                if (s1 !== peg$FAILED) {
                    peg$reportedPos = s0;
                    s1 = peg$c11();
                }
                s0 = s1;
                if (s0 === peg$FAILED) {
                    s0 = peg$currPos;
                    if (input.charCodeAt(peg$currPos) === 86) {
                        s1 = peg$c12;
                        peg$currPos++;
                    } else {
                        s1 = peg$FAILED;
                        if (peg$silentFails === 0) {
                            peg$fail(peg$c13);
                        }
                    }
                    if (s1 !== peg$FAILED) {
                        peg$reportedPos = s0;
                        s1 = peg$c14();
                    }
                    s0 = s1;
                    if (s0 === peg$FAILED) {
                        s0 = peg$currPos;
                        if (input.charCodeAt(peg$currPos) === 90) {
                            s1 = peg$c15;
                            peg$currPos++;
                        } else {
                            s1 = peg$FAILED;
                            if (peg$silentFails === 0) {
                                peg$fail(peg$c16);
                            }
                        }
                        if (s1 !== peg$FAILED) {
                            peg$reportedPos = s0;
                            s1 = peg$c17();
                        }
                        s0 = s1;
                    }
                }
            }

            return s0;
        }

        function peg$parsecomments() {
            var s0, s1, s2, s3, s4;

            s0 = peg$currPos;
            s1 = [];
            if (input.charCodeAt(peg$currPos) === 32) {
                s2 = peg$c18;
                peg$currPos++;
            } else {
                s2 = peg$FAILED;
                if (peg$silentFails === 0) {
                    peg$fail(peg$c19);
                }
            }
            while (s2 !== peg$FAILED) {
                s1.push(s2);
                if (input.charCodeAt(peg$currPos) === 32) {
                    s2 = peg$c18;
                    peg$currPos++;
                } else {
                    s2 = peg$FAILED;
                    if (peg$silentFails === 0) {
                        peg$fail(peg$c19);
                    }
                }
            }
            if (s1 !== peg$FAILED) {
                if (input.substr(peg$currPos, 2) === peg$c20) {
                    s2 = peg$c20;
                    peg$currPos += 2;
                } else {
                    s2 = peg$FAILED;
                    if (peg$silentFails === 0) {
                        peg$fail(peg$c21);
                    }
                }
                if (s2 !== peg$FAILED) {
                    s3 = [];
                    if (input.length > peg$currPos) {
                        s4 = input.charAt(peg$currPos);
                        peg$currPos++;
                    } else {
                        s4 = peg$FAILED;
                        if (peg$silentFails === 0) {
                            peg$fail(peg$c22);
                        }
                    }
                    while (s4 !== peg$FAILED) {
                        s3.push(s4);
                        if (input.length > peg$currPos) {
                            s4 = input.charAt(peg$currPos);
                            peg$currPos++;
                        } else {
                            s4 = peg$FAILED;
                            if (peg$silentFails === 0) {
                                peg$fail(peg$c22);
                            }
                        }
                    }
                    if (s3 !== peg$FAILED) {
                        s1 = [s1, s2, s3];
                        s0 = s1;
                    } else {
                        peg$currPos = s0;
                        s0 = peg$c0;
                    }
                } else {
                    peg$currPos = s0;
                    s0 = peg$c0;
                }
            } else {
                peg$currPos = s0;
                s0 = peg$c0;
            }

            return s0;
        }

        function peg$parsesuperview() {
            var s0, s1;

            s0 = peg$currPos;
            if (input.charCodeAt(peg$currPos) === 124) {
                s1 = peg$c23;
                peg$currPos++;
            } else {
                s1 = peg$FAILED;
                if (peg$silentFails === 0) {
                    peg$fail(peg$c24);
                }
            }
            if (s1 !== peg$FAILED) {
                peg$reportedPos = s0;
                s1 = peg$c25();
            }
            s0 = s1;

            return s0;
        }

        function peg$parseviewGroup() {
            var s0, s1, s2, s3, s4, s5, s6;

            s0 = peg$currPos;
            if (input.charCodeAt(peg$currPos) === 91) {
                s1 = peg$c26;
                peg$currPos++;
            } else {
                s1 = peg$FAILED;
                if (peg$silentFails === 0) {
                    peg$fail(peg$c27);
                }
            }
            if (s1 !== peg$FAILED) {
                s2 = peg$parseview();
                if (s2 !== peg$FAILED) {
                    s3 = [];
                    s4 = peg$currPos;
                    if (input.charCodeAt(peg$currPos) === 44) {
                        s5 = peg$c28;
                        peg$currPos++;
                    } else {
                        s5 = peg$FAILED;
                        if (peg$silentFails === 0) {
                            peg$fail(peg$c29);
                        }
                    }
                    if (s5 !== peg$FAILED) {
                        s6 = peg$parseview();
                        if (s6 !== peg$FAILED) {
                            s5 = [s5, s6];
                            s4 = s5;
                        } else {
                            peg$currPos = s4;
                            s4 = peg$c0;
                        }
                    } else {
                        peg$currPos = s4;
                        s4 = peg$c0;
                    }
                    while (s4 !== peg$FAILED) {
                        s3.push(s4);
                        s4 = peg$currPos;
                        if (input.charCodeAt(peg$currPos) === 44) {
                            s5 = peg$c28;
                            peg$currPos++;
                        } else {
                            s5 = peg$FAILED;
                            if (peg$silentFails === 0) {
                                peg$fail(peg$c29);
                            }
                        }
                        if (s5 !== peg$FAILED) {
                            s6 = peg$parseview();
                            if (s6 !== peg$FAILED) {
                                s5 = [s5, s6];
                                s4 = s5;
                            } else {
                                peg$currPos = s4;
                                s4 = peg$c0;
                            }
                        } else {
                            peg$currPos = s4;
                            s4 = peg$c0;
                        }
                    }
                    if (s3 !== peg$FAILED) {
                        if (input.charCodeAt(peg$currPos) === 93) {
                            s4 = peg$c30;
                            peg$currPos++;
                        } else {
                            s4 = peg$FAILED;
                            if (peg$silentFails === 0) {
                                peg$fail(peg$c31);
                            }
                        }
                        if (s4 !== peg$FAILED) {
                            peg$reportedPos = s0;
                            s1 = peg$c32(s2, s3);
                            s0 = s1;
                        } else {
                            peg$currPos = s0;
                            s0 = peg$c0;
                        }
                    } else {
                        peg$currPos = s0;
                        s0 = peg$c0;
                    }
                } else {
                    peg$currPos = s0;
                    s0 = peg$c0;
                }
            } else {
                peg$currPos = s0;
                s0 = peg$c0;
            }

            return s0;
        }

        function peg$parseview() {
            var s0, s1, s2, s3;

            s0 = peg$currPos;
            s1 = peg$parseviewNameRange();
            if (s1 !== peg$FAILED) {
                s2 = peg$parsepredicateListWithParens();
                if (s2 === peg$FAILED) {
                    s2 = peg$c1;
                }
                if (s2 !== peg$FAILED) {
                    s3 = peg$parsecascadedViews();
                    if (s3 === peg$FAILED) {
                        s3 = peg$c1;
                    }
                    if (s3 !== peg$FAILED) {
                        peg$reportedPos = s0;
                        s1 = peg$c33(s1, s2, s3);
                        s0 = s1;
                    } else {
                        peg$currPos = s0;
                        s0 = peg$c0;
                    }
                } else {
                    peg$currPos = s0;
                    s0 = peg$c0;
                }
            } else {
                peg$currPos = s0;
                s0 = peg$c0;
            }

            return s0;
        }

        function peg$parsecascadedViews() {
            var s0, s1, s2, s3, s4, s5;

            s0 = peg$currPos;
            if (input.charCodeAt(peg$currPos) === 58) {
                s1 = peg$c2;
                peg$currPos++;
            } else {
                s1 = peg$FAILED;
                if (peg$silentFails === 0) {
                    peg$fail(peg$c3);
                }
            }
            if (s1 !== peg$FAILED) {
                s2 = [];
                s3 = peg$currPos;
                s4 = peg$parseconnection();
                if (s4 !== peg$FAILED) {
                    s5 = peg$parseviewGroup();
                    if (s5 !== peg$FAILED) {
                        s4 = [s4, s5];
                        s3 = s4;
                    } else {
                        peg$currPos = s3;
                        s3 = peg$c0;
                    }
                } else {
                    peg$currPos = s3;
                    s3 = peg$c0;
                }
                if (s3 !== peg$FAILED) {
                    while (s3 !== peg$FAILED) {
                        s2.push(s3);
                        s3 = peg$currPos;
                        s4 = peg$parseconnection();
                        if (s4 !== peg$FAILED) {
                            s5 = peg$parseviewGroup();
                            if (s5 !== peg$FAILED) {
                                s4 = [s4, s5];
                                s3 = s4;
                            } else {
                                peg$currPos = s3;
                                s3 = peg$c0;
                            }
                        } else {
                            peg$currPos = s3;
                            s3 = peg$c0;
                        }
                    }
                } else {
                    s2 = peg$c0;
                }
                if (s2 !== peg$FAILED) {
                    s3 = peg$parseconnection();
                    if (s3 !== peg$FAILED) {
                        peg$reportedPos = s0;
                        s1 = peg$c34(s2, s3);
                        s0 = s1;
                    } else {
                        peg$currPos = s0;
                        s0 = peg$c0;
                    }
                } else {
                    peg$currPos = s0;
                    s0 = peg$c0;
                }
            } else {
                peg$currPos = s0;
                s0 = peg$c0;
            }

            return s0;
        }

        function peg$parseconnection() {
            var s0, s1, s2, s3;

            s0 = peg$currPos;
            if (input.substr(peg$currPos, 2) === peg$c35) {
                s1 = peg$c35;
                peg$currPos += 2;
            } else {
                s1 = peg$FAILED;
                if (peg$silentFails === 0) {
                    peg$fail(peg$c36);
                }
            }
            if (s1 !== peg$FAILED) {
                peg$reportedPos = s0;
                s1 = peg$c37();
            }
            s0 = s1;
            if (s0 === peg$FAILED) {
                s0 = peg$currPos;
                if (input.charCodeAt(peg$currPos) === 45) {
                    s1 = peg$c38;
                    peg$currPos++;
                } else {
                    s1 = peg$FAILED;
                    if (peg$silentFails === 0) {
                        peg$fail(peg$c39);
                    }
                }
                if (s1 !== peg$FAILED) {
                    s2 = peg$parsepredicateList();
                    if (s2 !== peg$FAILED) {
                        if (input.charCodeAt(peg$currPos) === 45) {
                            s3 = peg$c38;
                            peg$currPos++;
                        } else {
                            s3 = peg$FAILED;
                            if (peg$silentFails === 0) {
                                peg$fail(peg$c39);
                            }
                        }
                        if (s3 !== peg$FAILED) {
                            peg$reportedPos = s0;
                            s1 = peg$c40(s2);
                            s0 = s1;
                        } else {
                            peg$currPos = s0;
                            s0 = peg$c0;
                        }
                    } else {
                        peg$currPos = s0;
                        s0 = peg$c0;
                    }
                } else {
                    peg$currPos = s0;
                    s0 = peg$c0;
                }
                if (s0 === peg$FAILED) {
                    s0 = peg$currPos;
                    if (input.charCodeAt(peg$currPos) === 45) {
                        s1 = peg$c38;
                        peg$currPos++;
                    } else {
                        s1 = peg$FAILED;
                        if (peg$silentFails === 0) {
                            peg$fail(peg$c39);
                        }
                    }
                    if (s1 !== peg$FAILED) {
                        peg$reportedPos = s0;
                        s1 = peg$c41();
                    }
                    s0 = s1;
                    if (s0 === peg$FAILED) {
                        s0 = peg$currPos;
                        if (input.charCodeAt(peg$currPos) === 126) {
                            s1 = peg$c42;
                            peg$currPos++;
                        } else {
                            s1 = peg$FAILED;
                            if (peg$silentFails === 0) {
                                peg$fail(peg$c43);
                            }
                        }
                        if (s1 !== peg$FAILED) {
                            s2 = peg$parseequalSpacingPredicateList();
                            if (s2 !== peg$FAILED) {
                                if (input.charCodeAt(peg$currPos) === 126) {
                                    s3 = peg$c42;
                                    peg$currPos++;
                                } else {
                                    s3 = peg$FAILED;
                                    if (peg$silentFails === 0) {
                                        peg$fail(peg$c43);
                                    }
                                }
                                if (s3 !== peg$FAILED) {
                                    peg$reportedPos = s0;
                                    s1 = peg$c40(s2);
                                    s0 = s1;
                                } else {
                                    peg$currPos = s0;
                                    s0 = peg$c0;
                                }
                            } else {
                                peg$currPos = s0;
                                s0 = peg$c0;
                            }
                        } else {
                            peg$currPos = s0;
                            s0 = peg$c0;
                        }
                        if (s0 === peg$FAILED) {
                            s0 = peg$currPos;
                            if (input.charCodeAt(peg$currPos) === 126) {
                                s1 = peg$c42;
                                peg$currPos++;
                            } else {
                                s1 = peg$FAILED;
                                if (peg$silentFails === 0) {
                                    peg$fail(peg$c43);
                                }
                            }
                            if (s1 !== peg$FAILED) {
                                peg$reportedPos = s0;
                                s1 = peg$c44();
                            }
                            s0 = s1;
                            if (s0 === peg$FAILED) {
                                s0 = peg$currPos;
                                s1 = peg$c45;
                                if (s1 !== peg$FAILED) {
                                    peg$reportedPos = s0;
                                    s1 = peg$c46();
                                }
                                s0 = s1;
                            }
                        }
                    }
                }
            }

            return s0;
        }

        function peg$parsepredicateList() {
            var s0;

            s0 = peg$parsesimplePredicate();
            if (s0 === peg$FAILED) {
                s0 = peg$parsepredicateListWithParens();
            }

            return s0;
        }

        function peg$parsesimplePredicate() {
            var s0, s1;

            s0 = peg$currPos;
            s1 = peg$parsepercentage();
            if (s1 !== peg$FAILED) {
                peg$reportedPos = s0;
                s1 = peg$c47(s1);
            }
            s0 = s1;
            if (s0 === peg$FAILED) {
                s0 = peg$currPos;
                s1 = peg$parsenumber();
                if (s1 !== peg$FAILED) {
                    peg$reportedPos = s0;
                    s1 = peg$c48(s1);
                }
                s0 = s1;
            }

            return s0;
        }

        function peg$parsepredicateListWithParens() {
            var s0, s1, s2, s3, s4, s5, s6;

            s0 = peg$currPos;
            if (input.charCodeAt(peg$currPos) === 40) {
                s1 = peg$c49;
                peg$currPos++;
            } else {
                s1 = peg$FAILED;
                if (peg$silentFails === 0) {
                    peg$fail(peg$c50);
                }
            }
            if (s1 !== peg$FAILED) {
                s2 = peg$parsepredicate();
                if (s2 !== peg$FAILED) {
                    s3 = [];
                    s4 = peg$currPos;
                    if (input.charCodeAt(peg$currPos) === 44) {
                        s5 = peg$c28;
                        peg$currPos++;
                    } else {
                        s5 = peg$FAILED;
                        if (peg$silentFails === 0) {
                            peg$fail(peg$c29);
                        }
                    }
                    if (s5 !== peg$FAILED) {
                        s6 = peg$parsepredicate();
                        if (s6 !== peg$FAILED) {
                            s5 = [s5, s6];
                            s4 = s5;
                        } else {
                            peg$currPos = s4;
                            s4 = peg$c0;
                        }
                    } else {
                        peg$currPos = s4;
                        s4 = peg$c0;
                    }
                    while (s4 !== peg$FAILED) {
                        s3.push(s4);
                        s4 = peg$currPos;
                        if (input.charCodeAt(peg$currPos) === 44) {
                            s5 = peg$c28;
                            peg$currPos++;
                        } else {
                            s5 = peg$FAILED;
                            if (peg$silentFails === 0) {
                                peg$fail(peg$c29);
                            }
                        }
                        if (s5 !== peg$FAILED) {
                            s6 = peg$parsepredicate();
                            if (s6 !== peg$FAILED) {
                                s5 = [s5, s6];
                                s4 = s5;
                            } else {
                                peg$currPos = s4;
                                s4 = peg$c0;
                            }
                        } else {
                            peg$currPos = s4;
                            s4 = peg$c0;
                        }
                    }
                    if (s3 !== peg$FAILED) {
                        if (input.charCodeAt(peg$currPos) === 41) {
                            s4 = peg$c51;
                            peg$currPos++;
                        } else {
                            s4 = peg$FAILED;
                            if (peg$silentFails === 0) {
                                peg$fail(peg$c52);
                            }
                        }
                        if (s4 !== peg$FAILED) {
                            peg$reportedPos = s0;
                            s1 = peg$c53(s2, s3);
                            s0 = s1;
                        } else {
                            peg$currPos = s0;
                            s0 = peg$c0;
                        }
                    } else {
                        peg$currPos = s0;
                        s0 = peg$c0;
                    }
                } else {
                    peg$currPos = s0;
                    s0 = peg$c0;
                }
            } else {
                peg$currPos = s0;
                s0 = peg$c0;
            }

            return s0;
        }

        function peg$parsepredicate() {
            var s0, s1, s2, s3, s4, s5;

            s0 = peg$currPos;
            s1 = peg$parserelation();
            if (s1 === peg$FAILED) {
                s1 = peg$c1;
            }
            if (s1 !== peg$FAILED) {
                s2 = peg$parseobjectOfPredicate();
                if (s2 !== peg$FAILED) {
                    s3 = peg$currPos;
                    if (input.charCodeAt(peg$currPos) === 64) {
                        s4 = peg$c54;
                        peg$currPos++;
                    } else {
                        s4 = peg$FAILED;
                        if (peg$silentFails === 0) {
                            peg$fail(peg$c55);
                        }
                    }
                    if (s4 !== peg$FAILED) {
                        s5 = peg$parsepriority();
                        if (s5 !== peg$FAILED) {
                            s4 = [s4, s5];
                            s3 = s4;
                        } else {
                            peg$currPos = s3;
                            s3 = peg$c0;
                        }
                    } else {
                        peg$currPos = s3;
                        s3 = peg$c0;
                    }
                    if (s3 === peg$FAILED) {
                        s3 = peg$c1;
                    }
                    if (s3 !== peg$FAILED) {
                        peg$reportedPos = s0;
                        s1 = peg$c56(s1, s2, s3);
                        s0 = s1;
                    } else {
                        peg$currPos = s0;
                        s0 = peg$c0;
                    }
                } else {
                    peg$currPos = s0;
                    s0 = peg$c0;
                }
            } else {
                peg$currPos = s0;
                s0 = peg$c0;
            }

            return s0;
        }

        function peg$parseequalSpacingPredicateList() {
            var s0, s1, s2, s3, s4, s5, s6;

            s0 = peg$currPos;
            if (input.charCodeAt(peg$currPos) === 40) {
                s1 = peg$c49;
                peg$currPos++;
            } else {
                s1 = peg$FAILED;
                if (peg$silentFails === 0) {
                    peg$fail(peg$c50);
                }
            }
            if (s1 !== peg$FAILED) {
                s2 = peg$parseequalSpacingPredicate();
                if (s2 !== peg$FAILED) {
                    s3 = [];
                    s4 = peg$currPos;
                    if (input.charCodeAt(peg$currPos) === 44) {
                        s5 = peg$c28;
                        peg$currPos++;
                    } else {
                        s5 = peg$FAILED;
                        if (peg$silentFails === 0) {
                            peg$fail(peg$c29);
                        }
                    }
                    if (s5 !== peg$FAILED) {
                        s6 = peg$parseequalSpacingPredicate();
                        if (s6 !== peg$FAILED) {
                            s5 = [s5, s6];
                            s4 = s5;
                        } else {
                            peg$currPos = s4;
                            s4 = peg$c0;
                        }
                    } else {
                        peg$currPos = s4;
                        s4 = peg$c0;
                    }
                    while (s4 !== peg$FAILED) {
                        s3.push(s4);
                        s4 = peg$currPos;
                        if (input.charCodeAt(peg$currPos) === 44) {
                            s5 = peg$c28;
                            peg$currPos++;
                        } else {
                            s5 = peg$FAILED;
                            if (peg$silentFails === 0) {
                                peg$fail(peg$c29);
                            }
                        }
                        if (s5 !== peg$FAILED) {
                            s6 = peg$parseequalSpacingPredicate();
                            if (s6 !== peg$FAILED) {
                                s5 = [s5, s6];
                                s4 = s5;
                            } else {
                                peg$currPos = s4;
                                s4 = peg$c0;
                            }
                        } else {
                            peg$currPos = s4;
                            s4 = peg$c0;
                        }
                    }
                    if (s3 !== peg$FAILED) {
                        if (input.charCodeAt(peg$currPos) === 41) {
                            s4 = peg$c51;
                            peg$currPos++;
                        } else {
                            s4 = peg$FAILED;
                            if (peg$silentFails === 0) {
                                peg$fail(peg$c52);
                            }
                        }
                        if (s4 !== peg$FAILED) {
                            peg$reportedPos = s0;
                            s1 = peg$c53(s2, s3);
                            s0 = s1;
                        } else {
                            peg$currPos = s0;
                            s0 = peg$c0;
                        }
                    } else {
                        peg$currPos = s0;
                        s0 = peg$c0;
                    }
                } else {
                    peg$currPos = s0;
                    s0 = peg$c0;
                }
            } else {
                peg$currPos = s0;
                s0 = peg$c0;
            }

            return s0;
        }

        function peg$parseequalSpacingPredicate() {
            var s0, s1, s2, s3, s4, s5;

            s0 = peg$currPos;
            s1 = peg$parserelation();
            if (s1 === peg$FAILED) {
                s1 = peg$c1;
            }
            if (s1 !== peg$FAILED) {
                s2 = peg$parseobjectOfPredicate();
                if (s2 !== peg$FAILED) {
                    s3 = peg$currPos;
                    if (input.charCodeAt(peg$currPos) === 64) {
                        s4 = peg$c54;
                        peg$currPos++;
                    } else {
                        s4 = peg$FAILED;
                        if (peg$silentFails === 0) {
                            peg$fail(peg$c55);
                        }
                    }
                    if (s4 !== peg$FAILED) {
                        s5 = peg$parsepriority();
                        if (s5 !== peg$FAILED) {
                            s4 = [s4, s5];
                            s3 = s4;
                        } else {
                            peg$currPos = s3;
                            s3 = peg$c0;
                        }
                    } else {
                        peg$currPos = s3;
                        s3 = peg$c0;
                    }
                    if (s3 === peg$FAILED) {
                        s3 = peg$c1;
                    }
                    if (s3 !== peg$FAILED) {
                        peg$reportedPos = s0;
                        s1 = peg$c57(s1, s2, s3);
                        s0 = s1;
                    } else {
                        peg$currPos = s0;
                        s0 = peg$c0;
                    }
                } else {
                    peg$currPos = s0;
                    s0 = peg$c0;
                }
            } else {
                peg$currPos = s0;
                s0 = peg$c0;
            }

            return s0;
        }

        function peg$parserelation() {
            var s0, s1;

            s0 = peg$currPos;
            if (input.substr(peg$currPos, 2) === peg$c58) {
                s1 = peg$c58;
                peg$currPos += 2;
            } else {
                s1 = peg$FAILED;
                if (peg$silentFails === 0) {
                    peg$fail(peg$c59);
                }
            }
            if (s1 !== peg$FAILED) {
                peg$reportedPos = s0;
                s1 = peg$c60();
            }
            s0 = s1;
            if (s0 === peg$FAILED) {
                s0 = peg$currPos;
                if (input.substr(peg$currPos, 2) === peg$c61) {
                    s1 = peg$c61;
                    peg$currPos += 2;
                } else {
                    s1 = peg$FAILED;
                    if (peg$silentFails === 0) {
                        peg$fail(peg$c62);
                    }
                }
                if (s1 !== peg$FAILED) {
                    peg$reportedPos = s0;
                    s1 = peg$c63();
                }
                s0 = s1;
                if (s0 === peg$FAILED) {
                    s0 = peg$currPos;
                    if (input.substr(peg$currPos, 2) === peg$c64) {
                        s1 = peg$c64;
                        peg$currPos += 2;
                    } else {
                        s1 = peg$FAILED;
                        if (peg$silentFails === 0) {
                            peg$fail(peg$c65);
                        }
                    }
                    if (s1 !== peg$FAILED) {
                        peg$reportedPos = s0;
                        s1 = peg$c66();
                    }
                    s0 = s1;
                }
            }

            return s0;
        }

        function peg$parseobjectOfPredicate() {
            var s0;

            s0 = peg$parsepercentage();
            if (s0 === peg$FAILED) {
                s0 = peg$parseconstant();
                if (s0 === peg$FAILED) {
                    s0 = peg$parseviewPredicate();
                }
            }

            return s0;
        }

        function peg$parsepriority() {
            var s0, s1, s2;

            s0 = peg$currPos;
            s1 = [];
            if (peg$c67.test(input.charAt(peg$currPos))) {
                s2 = input.charAt(peg$currPos);
                peg$currPos++;
            } else {
                s2 = peg$FAILED;
                if (peg$silentFails === 0) {
                    peg$fail(peg$c68);
                }
            }
            if (s2 !== peg$FAILED) {
                while (s2 !== peg$FAILED) {
                    s1.push(s2);
                    if (peg$c67.test(input.charAt(peg$currPos))) {
                        s2 = input.charAt(peg$currPos);
                        peg$currPos++;
                    } else {
                        s2 = peg$FAILED;
                        if (peg$silentFails === 0) {
                            peg$fail(peg$c68);
                        }
                    }
                }
            } else {
                s1 = peg$c0;
            }
            if (s1 !== peg$FAILED) {
                peg$reportedPos = s0;
                s1 = peg$c69(s1);
            }
            s0 = s1;

            return s0;
        }

        function peg$parseconstant() {
            var s0, s1;

            s0 = peg$currPos;
            s1 = peg$parsenumber();
            if (s1 !== peg$FAILED) {
                peg$reportedPos = s0;
                s1 = peg$c70(s1);
            }
            s0 = s1;

            return s0;
        }

        function peg$parsepercentage() {
            var s0, s1, s2;

            s0 = peg$currPos;
            s1 = peg$parsenumber();
            if (s1 !== peg$FAILED) {
                if (input.charCodeAt(peg$currPos) === 37) {
                    s2 = peg$c71;
                    peg$currPos++;
                } else {
                    s2 = peg$FAILED;
                    if (peg$silentFails === 0) {
                        peg$fail(peg$c72);
                    }
                }
                if (s2 !== peg$FAILED) {
                    peg$reportedPos = s0;
                    s1 = peg$c73(s1);
                    s0 = s1;
                } else {
                    peg$currPos = s0;
                    s0 = peg$c0;
                }
            } else {
                peg$currPos = s0;
                s0 = peg$c0;
            }

            return s0;
        }

        function peg$parseviewPredicate() {
            var s0, s1, s2, s3, s4;

            s0 = peg$currPos;
            s1 = peg$parseviewName();
            if (s1 !== peg$FAILED) {
                s2 = peg$parseattribute();
                if (s2 === peg$FAILED) {
                    s2 = peg$c1;
                }
                if (s2 !== peg$FAILED) {
                    s3 = peg$parsemultiplier();
                    if (s3 === peg$FAILED) {
                        s3 = peg$c1;
                    }
                    if (s3 !== peg$FAILED) {
                        s4 = peg$parseconstantExpr();
                        if (s4 === peg$FAILED) {
                            s4 = peg$c1;
                        }
                        if (s4 !== peg$FAILED) {
                            peg$reportedPos = s0;
                            s1 = peg$c74(s1, s2, s3, s4);
                            s0 = s1;
                        } else {
                            peg$currPos = s0;
                            s0 = peg$c0;
                        }
                    } else {
                        peg$currPos = s0;
                        s0 = peg$c0;
                    }
                } else {
                    peg$currPos = s0;
                    s0 = peg$c0;
                }
            } else {
                peg$currPos = s0;
                s0 = peg$c0;
            }

            return s0;
        }

        function peg$parseattribute() {
            var s0, s1;

            s0 = peg$currPos;
            if (input.substr(peg$currPos, 5) === peg$c75) {
                s1 = peg$c75;
                peg$currPos += 5;
            } else {
                s1 = peg$FAILED;
                if (peg$silentFails === 0) {
                    peg$fail(peg$c76);
                }
            }
            if (s1 !== peg$FAILED) {
                peg$reportedPos = s0;
                s1 = peg$c77();
            }
            s0 = s1;
            if (s0 === peg$FAILED) {
                s0 = peg$currPos;
                if (input.substr(peg$currPos, 6) === peg$c78) {
                    s1 = peg$c78;
                    peg$currPos += 6;
                } else {
                    s1 = peg$FAILED;
                    if (peg$silentFails === 0) {
                        peg$fail(peg$c79);
                    }
                }
                if (s1 !== peg$FAILED) {
                    peg$reportedPos = s0;
                    s1 = peg$c80();
                }
                s0 = s1;
                if (s0 === peg$FAILED) {
                    s0 = peg$currPos;
                    if (input.substr(peg$currPos, 4) === peg$c81) {
                        s1 = peg$c81;
                        peg$currPos += 4;
                    } else {
                        s1 = peg$FAILED;
                        if (peg$silentFails === 0) {
                            peg$fail(peg$c82);
                        }
                    }
                    if (s1 !== peg$FAILED) {
                        peg$reportedPos = s0;
                        s1 = peg$c83();
                    }
                    s0 = s1;
                    if (s0 === peg$FAILED) {
                        s0 = peg$currPos;
                        if (input.substr(peg$currPos, 7) === peg$c84) {
                            s1 = peg$c84;
                            peg$currPos += 7;
                        } else {
                            s1 = peg$FAILED;
                            if (peg$silentFails === 0) {
                                peg$fail(peg$c85);
                            }
                        }
                        if (s1 !== peg$FAILED) {
                            peg$reportedPos = s0;
                            s1 = peg$c86();
                        }
                        s0 = s1;
                        if (s0 === peg$FAILED) {
                            s0 = peg$currPos;
                            if (input.substr(peg$currPos, 6) === peg$c87) {
                                s1 = peg$c87;
                                peg$currPos += 6;
                            } else {
                                s1 = peg$FAILED;
                                if (peg$silentFails === 0) {
                                    peg$fail(peg$c88);
                                }
                            }
                            if (s1 !== peg$FAILED) {
                                peg$reportedPos = s0;
                                s1 = peg$c89();
                            }
                            s0 = s1;
                            if (s0 === peg$FAILED) {
                                s0 = peg$currPos;
                                if (input.substr(peg$currPos, 7) === peg$c90) {
                                    s1 = peg$c90;
                                    peg$currPos += 7;
                                } else {
                                    s1 = peg$FAILED;
                                    if (peg$silentFails === 0) {
                                        peg$fail(peg$c91);
                                    }
                                }
                                if (s1 !== peg$FAILED) {
                                    peg$reportedPos = s0;
                                    s1 = peg$c92();
                                }
                                s0 = s1;
                                if (s0 === peg$FAILED) {
                                    s0 = peg$currPos;
                                    if (input.substr(peg$currPos, 8) === peg$c93) {
                                        s1 = peg$c93;
                                        peg$currPos += 8;
                                    } else {
                                        s1 = peg$FAILED;
                                        if (peg$silentFails === 0) {
                                            peg$fail(peg$c94);
                                        }
                                    }
                                    if (s1 !== peg$FAILED) {
                                        peg$reportedPos = s0;
                                        s1 = peg$c95();
                                    }
                                    s0 = s1;
                                    if (s0 === peg$FAILED) {
                                        s0 = peg$currPos;
                                        if (input.substr(peg$currPos, 8) === peg$c96) {
                                            s1 = peg$c96;
                                            peg$currPos += 8;
                                        } else {
                                            s1 = peg$FAILED;
                                            if (peg$silentFails === 0) {
                                                peg$fail(peg$c97);
                                            }
                                        }
                                        if (s1 !== peg$FAILED) {
                                            peg$reportedPos = s0;
                                            s1 = peg$c98();
                                        }
                                        s0 = s1;
                                    }
                                }
                            }
                        }
                    }
                }
            }

            return s0;
        }

        function peg$parsemultiplier() {
            var s0, s1, s2;

            s0 = peg$currPos;
            if (input.charCodeAt(peg$currPos) === 47) {
                s1 = peg$c99;
                peg$currPos++;
            } else {
                s1 = peg$FAILED;
                if (peg$silentFails === 0) {
                    peg$fail(peg$c100);
                }
            }
            if (s1 !== peg$FAILED) {
                s2 = peg$parsenumber();
                if (s2 !== peg$FAILED) {
                    peg$reportedPos = s0;
                    s1 = peg$c101(s2);
                    s0 = s1;
                } else {
                    peg$currPos = s0;
                    s0 = peg$c0;
                }
            } else {
                peg$currPos = s0;
                s0 = peg$c0;
            }
            if (s0 === peg$FAILED) {
                s0 = peg$currPos;
                if (input.charCodeAt(peg$currPos) === 42) {
                    s1 = peg$c102;
                    peg$currPos++;
                } else {
                    s1 = peg$FAILED;
                    if (peg$silentFails === 0) {
                        peg$fail(peg$c103);
                    }
                }
                if (s1 !== peg$FAILED) {
                    s2 = peg$parsenumber();
                    if (s2 !== peg$FAILED) {
                        peg$reportedPos = s0;
                        s1 = peg$c104(s2);
                        s0 = s1;
                    } else {
                        peg$currPos = s0;
                        s0 = peg$c0;
                    }
                } else {
                    peg$currPos = s0;
                    s0 = peg$c0;
                }
            }

            return s0;
        }

        function peg$parseconstantExpr() {
            var s0, s1, s2;

            s0 = peg$currPos;
            if (input.charCodeAt(peg$currPos) === 45) {
                s1 = peg$c38;
                peg$currPos++;
            } else {
                s1 = peg$FAILED;
                if (peg$silentFails === 0) {
                    peg$fail(peg$c39);
                }
            }
            if (s1 !== peg$FAILED) {
                s2 = peg$parsenumber();
                if (s2 !== peg$FAILED) {
                    peg$reportedPos = s0;
                    s1 = peg$c105(s2);
                    s0 = s1;
                } else {
                    peg$currPos = s0;
                    s0 = peg$c0;
                }
            } else {
                peg$currPos = s0;
                s0 = peg$c0;
            }
            if (s0 === peg$FAILED) {
                s0 = peg$currPos;
                if (input.charCodeAt(peg$currPos) === 43) {
                    s1 = peg$c106;
                    peg$currPos++;
                } else {
                    s1 = peg$FAILED;
                    if (peg$silentFails === 0) {
                        peg$fail(peg$c107);
                    }
                }
                if (s1 !== peg$FAILED) {
                    s2 = peg$parsenumber();
                    if (s2 !== peg$FAILED) {
                        peg$reportedPos = s0;
                        s1 = peg$c104(s2);
                        s0 = s1;
                    } else {
                        peg$currPos = s0;
                        s0 = peg$c0;
                    }
                } else {
                    peg$currPos = s0;
                    s0 = peg$c0;
                }
            }

            return s0;
        }

        function peg$parseviewNameRange() {
            var s0, s1, s2, s3, s4;

            s0 = peg$currPos;
            s1 = peg$currPos;
            s2 = [];
            if (peg$c108.test(input.charAt(peg$currPos))) {
                s3 = input.charAt(peg$currPos);
                peg$currPos++;
            } else {
                s3 = peg$FAILED;
                if (peg$silentFails === 0) {
                    peg$fail(peg$c109);
                }
            }
            if (s3 !== peg$FAILED) {
                while (s3 !== peg$FAILED) {
                    s2.push(s3);
                    if (peg$c108.test(input.charAt(peg$currPos))) {
                        s3 = input.charAt(peg$currPos);
                        peg$currPos++;
                    } else {
                        s3 = peg$FAILED;
                        if (peg$silentFails === 0) {
                            peg$fail(peg$c109);
                        }
                    }
                }
            } else {
                s2 = peg$c0;
            }
            if (s2 !== peg$FAILED) {
                s2 = input.substring(s1, peg$currPos);
            }
            s1 = s2;
            if (s1 !== peg$FAILED) {
                s2 = peg$currPos;
                s3 = [];
                if (peg$c110.test(input.charAt(peg$currPos))) {
                    s4 = input.charAt(peg$currPos);
                    peg$currPos++;
                } else {
                    s4 = peg$FAILED;
                    if (peg$silentFails === 0) {
                        peg$fail(peg$c111);
                    }
                }
                while (s4 !== peg$FAILED) {
                    s3.push(s4);
                    if (peg$c110.test(input.charAt(peg$currPos))) {
                        s4 = input.charAt(peg$currPos);
                        peg$currPos++;
                    } else {
                        s4 = peg$FAILED;
                        if (peg$silentFails === 0) {
                            peg$fail(peg$c111);
                        }
                    }
                }
                if (s3 !== peg$FAILED) {
                    s3 = input.substring(s2, peg$currPos);
                }
                s2 = s3;
                if (s2 !== peg$FAILED) {
                    s3 = peg$parserange();
                    if (s3 !== peg$FAILED) {
                        peg$reportedPos = s0;
                        s1 = peg$c112(s1, s2, s3);
                        s0 = s1;
                    } else {
                        peg$currPos = s0;
                        s0 = peg$c0;
                    }
                } else {
                    peg$currPos = s0;
                    s0 = peg$c0;
                }
            } else {
                peg$currPos = s0;
                s0 = peg$c0;
            }
            if (s0 === peg$FAILED) {
                s0 = peg$currPos;
                s1 = peg$currPos;
                s2 = [];
                if (peg$c108.test(input.charAt(peg$currPos))) {
                    s3 = input.charAt(peg$currPos);
                    peg$currPos++;
                } else {
                    s3 = peg$FAILED;
                    if (peg$silentFails === 0) {
                        peg$fail(peg$c109);
                    }
                }
                if (s3 !== peg$FAILED) {
                    while (s3 !== peg$FAILED) {
                        s2.push(s3);
                        if (peg$c108.test(input.charAt(peg$currPos))) {
                            s3 = input.charAt(peg$currPos);
                            peg$currPos++;
                        } else {
                            s3 = peg$FAILED;
                            if (peg$silentFails === 0) {
                                peg$fail(peg$c109);
                            }
                        }
                    }
                } else {
                    s2 = peg$c0;
                }
                if (s2 !== peg$FAILED) {
                    s2 = input.substring(s1, peg$currPos);
                }
                s1 = s2;
                if (s1 !== peg$FAILED) {
                    s2 = peg$currPos;
                    s3 = [];
                    if (peg$c110.test(input.charAt(peg$currPos))) {
                        s4 = input.charAt(peg$currPos);
                        peg$currPos++;
                    } else {
                        s4 = peg$FAILED;
                        if (peg$silentFails === 0) {
                            peg$fail(peg$c111);
                        }
                    }
                    while (s4 !== peg$FAILED) {
                        s3.push(s4);
                        if (peg$c110.test(input.charAt(peg$currPos))) {
                            s4 = input.charAt(peg$currPos);
                            peg$currPos++;
                        } else {
                            s4 = peg$FAILED;
                            if (peg$silentFails === 0) {
                                peg$fail(peg$c111);
                            }
                        }
                    }
                    if (s3 !== peg$FAILED) {
                        s3 = input.substring(s2, peg$currPos);
                    }
                    s2 = s3;
                    if (s2 !== peg$FAILED) {
                        peg$reportedPos = s0;
                        s1 = peg$c113(s1, s2);
                        s0 = s1;
                    } else {
                        peg$currPos = s0;
                        s0 = peg$c0;
                    }
                } else {
                    peg$currPos = s0;
                    s0 = peg$c0;
                }
            }

            return s0;
        }

        function peg$parseviewName() {
            var s0, s1, s2, s3, s4;

            s0 = peg$currPos;
            s1 = peg$currPos;
            s2 = [];
            if (peg$c108.test(input.charAt(peg$currPos))) {
                s3 = input.charAt(peg$currPos);
                peg$currPos++;
            } else {
                s3 = peg$FAILED;
                if (peg$silentFails === 0) {
                    peg$fail(peg$c109);
                }
            }
            if (s3 !== peg$FAILED) {
                while (s3 !== peg$FAILED) {
                    s2.push(s3);
                    if (peg$c108.test(input.charAt(peg$currPos))) {
                        s3 = input.charAt(peg$currPos);
                        peg$currPos++;
                    } else {
                        s3 = peg$FAILED;
                        if (peg$silentFails === 0) {
                            peg$fail(peg$c109);
                        }
                    }
                }
            } else {
                s2 = peg$c0;
            }
            if (s2 !== peg$FAILED) {
                s2 = input.substring(s1, peg$currPos);
            }
            s1 = s2;
            if (s1 !== peg$FAILED) {
                s2 = peg$currPos;
                s3 = [];
                if (peg$c110.test(input.charAt(peg$currPos))) {
                    s4 = input.charAt(peg$currPos);
                    peg$currPos++;
                } else {
                    s4 = peg$FAILED;
                    if (peg$silentFails === 0) {
                        peg$fail(peg$c111);
                    }
                }
                while (s4 !== peg$FAILED) {
                    s3.push(s4);
                    if (peg$c110.test(input.charAt(peg$currPos))) {
                        s4 = input.charAt(peg$currPos);
                        peg$currPos++;
                    } else {
                        s4 = peg$FAILED;
                        if (peg$silentFails === 0) {
                            peg$fail(peg$c111);
                        }
                    }
                }
                if (s3 !== peg$FAILED) {
                    s3 = input.substring(s2, peg$currPos);
                }
                s2 = s3;
                if (s2 !== peg$FAILED) {
                    peg$reportedPos = s0;
                    s1 = peg$c113(s1, s2);
                    s0 = s1;
                } else {
                    peg$currPos = s0;
                    s0 = peg$c0;
                }
            } else {
                peg$currPos = s0;
                s0 = peg$c0;
            }

            return s0;
        }

        function peg$parserange() {
            var s0, s1, s2, s3;

            s0 = peg$currPos;
            if (input.substr(peg$currPos, 2) === peg$c114) {
                s1 = peg$c114;
                peg$currPos += 2;
            } else {
                s1 = peg$FAILED;
                if (peg$silentFails === 0) {
                    peg$fail(peg$c115);
                }
            }
            if (s1 !== peg$FAILED) {
                s2 = [];
                if (peg$c67.test(input.charAt(peg$currPos))) {
                    s3 = input.charAt(peg$currPos);
                    peg$currPos++;
                } else {
                    s3 = peg$FAILED;
                    if (peg$silentFails === 0) {
                        peg$fail(peg$c68);
                    }
                }
                if (s3 !== peg$FAILED) {
                    while (s3 !== peg$FAILED) {
                        s2.push(s3);
                        if (peg$c67.test(input.charAt(peg$currPos))) {
                            s3 = input.charAt(peg$currPos);
                            peg$currPos++;
                        } else {
                            s3 = peg$FAILED;
                            if (peg$silentFails === 0) {
                                peg$fail(peg$c68);
                            }
                        }
                    }
                } else {
                    s2 = peg$c0;
                }
                if (s2 !== peg$FAILED) {
                    peg$reportedPos = s0;
                    s1 = peg$c116(s2);
                    s0 = s1;
                } else {
                    peg$currPos = s0;
                    s0 = peg$c0;
                }
            } else {
                peg$currPos = s0;
                s0 = peg$c0;
            }

            return s0;
        }

        function peg$parsenumber() {
            var s0, s1, s2, s3, s4;

            s0 = peg$currPos;
            s1 = [];
            if (peg$c67.test(input.charAt(peg$currPos))) {
                s2 = input.charAt(peg$currPos);
                peg$currPos++;
            } else {
                s2 = peg$FAILED;
                if (peg$silentFails === 0) {
                    peg$fail(peg$c68);
                }
            }
            if (s2 !== peg$FAILED) {
                while (s2 !== peg$FAILED) {
                    s1.push(s2);
                    if (peg$c67.test(input.charAt(peg$currPos))) {
                        s2 = input.charAt(peg$currPos);
                        peg$currPos++;
                    } else {
                        s2 = peg$FAILED;
                        if (peg$silentFails === 0) {
                            peg$fail(peg$c68);
                        }
                    }
                }
            } else {
                s1 = peg$c0;
            }
            if (s1 !== peg$FAILED) {
                if (input.charCodeAt(peg$currPos) === 46) {
                    s2 = peg$c117;
                    peg$currPos++;
                } else {
                    s2 = peg$FAILED;
                    if (peg$silentFails === 0) {
                        peg$fail(peg$c118);
                    }
                }
                if (s2 !== peg$FAILED) {
                    s3 = [];
                    if (peg$c67.test(input.charAt(peg$currPos))) {
                        s4 = input.charAt(peg$currPos);
                        peg$currPos++;
                    } else {
                        s4 = peg$FAILED;
                        if (peg$silentFails === 0) {
                            peg$fail(peg$c68);
                        }
                    }
                    if (s4 !== peg$FAILED) {
                        while (s4 !== peg$FAILED) {
                            s3.push(s4);
                            if (peg$c67.test(input.charAt(peg$currPos))) {
                                s4 = input.charAt(peg$currPos);
                                peg$currPos++;
                            } else {
                                s4 = peg$FAILED;
                                if (peg$silentFails === 0) {
                                    peg$fail(peg$c68);
                                }
                            }
                        }
                    } else {
                        s3 = peg$c0;
                    }
                    if (s3 !== peg$FAILED) {
                        peg$reportedPos = s0;
                        s1 = peg$c119(s1, s3);
                        s0 = s1;
                    } else {
                        peg$currPos = s0;
                        s0 = peg$c0;
                    }
                } else {
                    peg$currPos = s0;
                    s0 = peg$c0;
                }
            } else {
                peg$currPos = s0;
                s0 = peg$c0;
            }
            if (s0 === peg$FAILED) {
                s0 = peg$currPos;
                s1 = [];
                if (peg$c67.test(input.charAt(peg$currPos))) {
                    s2 = input.charAt(peg$currPos);
                    peg$currPos++;
                } else {
                    s2 = peg$FAILED;
                    if (peg$silentFails === 0) {
                        peg$fail(peg$c68);
                    }
                }
                if (s2 !== peg$FAILED) {
                    while (s2 !== peg$FAILED) {
                        s1.push(s2);
                        if (peg$c67.test(input.charAt(peg$currPos))) {
                            s2 = input.charAt(peg$currPos);
                            peg$currPos++;
                        } else {
                            s2 = peg$FAILED;
                            if (peg$silentFails === 0) {
                                peg$fail(peg$c68);
                            }
                        }
                    }
                } else {
                    s1 = peg$c0;
                }
                if (s1 !== peg$FAILED) {
                    peg$reportedPos = s0;
                    s1 = peg$c120(s1);
                }
                s0 = s1;
            }

            return s0;
        }

        function extend(dst) {
            for (var i = 1; i < arguments.length; i++) {
                for (var k in arguments[i]) {
                    dst[k] = arguments[i][k];
                }
            }
            return dst;
        }

        peg$result = peg$startRuleFunction();

        if (peg$result !== peg$FAILED && peg$currPos === input.length) {
            return peg$result;
        } else {
            if (peg$result !== peg$FAILED && peg$currPos < input.length) {
                peg$fail({
                    type: "end",
                    description: "end of input"
                });
            }

            throw peg$buildException(null, peg$maxFailExpected, peg$maxFailPos);
        }
    }

    return {
        SyntaxError: SyntaxError,
        parse: parse
    };
})();

var Orientation = {
    HORIZONTAL: 1,
    VERTICAL: 2,
    ZINDEX: 4
};

/**
 * Helper function that inserts equal spacers (~).
 * @private
 */
function _processEqualSpacer(context, stackView) {

    // Determine unique name for the spacer
    context.equalSpacerIndex = context.equalSpacerIndex || 1;
    var name = '_~' + context.lineIndex + ':' + context.equalSpacerIndex + '~';
    if (context.equalSpacerIndex > 1) {

        // Ensure that all spacers have the same width/height
        context.constraints.push({
            view1: '_~' + context.lineIndex + ':1~',
            attr1: context.horizontal ? Attribute.WIDTH : Attribute.HEIGHT,
            relation: context.relation.relation || Relation.EQU,
            view2: name,
            attr2: context.horizontal ? Attribute.WIDTH : Attribute.HEIGHT,
            priority: context.relation.priority
        });
    }
    context.equalSpacerIndex++;

    // Enforce view/proportional width/height
    if (context.relation.view || context.relation.multiplier && context.relation.multiplier !== 1) {
        context.constraints.push({
            view1: name,
            attr1: context.horizontal ? Attribute.WIDTH : Attribute.HEIGHT,
            relation: context.relation.relation || Relation.EQU,
            view2: context.relation.view,
            attr2: context.horizontal ? Attribute.WIDTH : Attribute.HEIGHT,
            priority: context.relation.priority,
            multiplier: context.relation.multiplier
        });
        context.relation.multiplier = undefined;
    } else if (context.relation.constant) {
        context.constraints.push({
            view1: name,
            attr1: context.horizontal ? Attribute.WIDTH : Attribute.HEIGHT,
            relation: Relation.EQU,
            view2: null,
            attr2: Attribute.CONST,
            priority: context.relation.priority,
            constant: context.relation.constant
        });
        context.relation.constant = undefined;
    }

    // Add constraint
    for (var i = 0; i < context.prevViews.length; i++) {
        var prevView = context.prevViews[i];
        switch (context.orientation) {
            case Orientation.HORIZONTAL:
                context.prevAttr = prevView !== stackView ? Attribute.RIGHT : Attribute.LEFT;
                context.curAttr = Attribute.LEFT;
                break;
            case Orientation.VERTICAL:
                context.prevAttr = prevView !== stackView ? Attribute.BOTTOM : Attribute.TOP;
                context.curAttr = Attribute.TOP;
                break;
            case Orientation.ZINDEX:
                context.prevAttr = Attribute.ZINDEX;
                context.curAttr = Attribute.ZINDEX;
                context.relation.constant = prevView !== stackView ? 'default' : 0;
                break;
        }
        context.constraints.push({
            view1: prevView,
            attr1: context.prevAttr,
            relation: context.relation.relation,
            view2: name,
            attr2: context.curAttr,
            priority: context.relation.priority
        });
    }
    context.prevViews = [name];
}

/**
 * Helper function that inserts proportional spacers (-12%-).
 * @private
 */
function _processProportionalSpacer(context, stackView) {
    context.proportionalSpacerIndex = context.proportionalSpacerIndex || 1;
    var name = '_-' + context.lineIndex + ':' + context.proportionalSpacerIndex + '-';
    context.proportionalSpacerIndex++;
    context.constraints.push({
        view1: name,
        attr1: context.horizontal ? Attribute.WIDTH : Attribute.HEIGHT,
        relation: context.relation.relation || Relation.EQU,
        view2: context.relation.view, // or relative to the stackView... food for thought
        attr2: context.horizontal ? Attribute.WIDTH : Attribute.HEIGHT,
        priority: context.relation.priority,
        multiplier: context.relation.multiplier
    });
    context.relation.multiplier = undefined;

    // Add constraint
    for (var i = 0; i < context.prevViews.length; i++) {
        var prevView = context.prevViews[i];
        switch (context.orientation) {
            case Orientation.HORIZONTAL:
                context.prevAttr = prevView !== stackView ? Attribute.RIGHT : Attribute.LEFT;
                context.curAttr = Attribute.LEFT;
                break;
            case Orientation.VERTICAL:
                context.prevAttr = prevView !== stackView ? Attribute.BOTTOM : Attribute.TOP;
                context.curAttr = Attribute.TOP;
                break;
            case Orientation.ZINDEX:
                context.prevAttr = Attribute.ZINDEX;
                context.curAttr = Attribute.ZINDEX;
                context.relation.constant = prevView !== stackView ? 'default' : 0;
                break;
        }
        context.constraints.push({
            view1: prevView,
            attr1: context.prevAttr,
            relation: context.relation.relation,
            view2: name,
            attr2: context.curAttr,
            priority: context.relation.priority
        });
    }
    context.prevViews = [name];
}

/**
 * In case of a stack-view, set constraints for opposite orientations
 * @private
 */
function _processStackView(context, name, subView) {
    var viewName = undefined;
    for (var orientation = 1; orientation <= 4; orientation *= 2) {
        if (subView.orientations & orientation && subView.stack.orientation !== orientation && !(subView.stack.processedOrientations & orientation)) {
            subView.stack.processedOrientations = subView.stack.processedOrientations | orientation;
            viewName = viewName || {
                name: name,
                type: 'stack'
            };
            for (var i = 0, j = subView.stack.subViews.length; i < j; i++) {
                if (orientation === Orientation.ZINDEX) {
                    context.constraints.push({
                        view1: viewName,
                        attr1: Attribute.ZINDEX,
                        relation: Relation.EQU,
                        view2: subView.stack.subViews[i],
                        attr2: Attribute.ZINDEX
                    });
                } else {
                    context.constraints.push({
                        view1: viewName,
                        attr1: orientation === Orientation.VERTICAL ? Attribute.HEIGHT : Attribute.WIDTH,
                        relation: Relation.EQU,
                        view2: subView.stack.subViews[i],
                        attr2: orientation === Orientation.VERTICAL ? Attribute.HEIGHT : Attribute.WIDTH
                    });
                    context.constraints.push({
                        view1: viewName,
                        attr1: orientation === Orientation.VERTICAL ? Attribute.TOP : Attribute.LEFT,
                        relation: Relation.EQU,
                        view2: subView.stack.subViews[i],
                        attr2: orientation === Orientation.VERTICAL ? Attribute.TOP : Attribute.LEFT
                    });
                }
            }
        }
    }
}

/**
 * Recursive helper function converts a view-name and a range to a series
 * of view-names (e.g. [child1, child2, child3, ...]).
 * @private
 */
function _getRange(name, range) {
    if (range === true) {
        range = name.match(/\.\.\d+$/);
        if (range) {
            name = name.substring(0, name.length - range[0].length);
            range = parseInt(range[0].substring(2));
        }
    }
    if (!range) {
        return [name];
    }
    var start = name.match(/\d+$/);
    var res = [];
    var i;
    if (start) {
        name = name.substring(0, name.length - start[0].length);
        for (i = parseInt(start); i <= range; i++) {
            res.push(name + i);
        }
    } else {
        res.push(name);
        for (i = 2; i <= range; i++) {
            res.push(name + i);
        }
    }
    return res;
}

/**
 * Recursive helper function that processes the cascaded data.
 * @private
 */
function _processCascade(context, cascade, parentItem) {
    var stackView = parentItem ? parentItem.view : null;
    var subViews = [];
    var curViews = [];
    var subView = undefined;
    if (stackView) {
        cascade.push({
            view: stackView
        });
        curViews.push(stackView);
    }
    for (var i = 0; i < cascade.length; i++) {
        var item = cascade[i];
        if (!Array.isArray(item) && item.hasOwnProperty('view') || Array.isArray(item) && item[0].view && !item[0].relation) {
            var items = Array.isArray(item) ? item : [item];
            for (var z = 0; z < items.length; z++) {
                item = items[z];
                var viewRange = item === ',' ? [] : item.view ? _getRange(item.view, item.range) : [null];
                for (var r = 0; r < viewRange.length; r++) {
                    var curView = viewRange[r];
                    curViews.push(curView);

                    //
                    // Add this view to the collection of subViews
                    //
                    if (curView !== stackView) {
                        subViews.push(curView);
                        subView = context.subViews[curView];
                        if (!subView) {
                            subView = {
                                orientations: 0
                            };
                            context.subViews[curView] = subView;
                        }
                        subView.orientations = subView.orientations | context.orientation;
                        if (subView.stack) {
                            _processStackView(context, curView, subView);
                        }
                    }

                    //
                    // Process the relationship between this and the previous views
                    //
                    if (context.prevViews !== undefined && curView !== undefined && context.relation) {
                        if (context.relation.relation !== 'none') {
                            for (var p = 0; p < context.prevViews.length; p++) {
                                var prevView = context.prevViews[p];
                                switch (context.orientation) {
                                    case Orientation.HORIZONTAL:
                                        context.prevAttr = prevView !== stackView ? Attribute.RIGHT : Attribute.LEFT;
                                        context.curAttr = curView !== stackView ? Attribute.LEFT : Attribute.RIGHT;
                                        break;
                                    case Orientation.VERTICAL:
                                        context.prevAttr = prevView !== stackView ? Attribute.BOTTOM : Attribute.TOP;
                                        context.curAttr = curView !== stackView ? Attribute.TOP : Attribute.BOTTOM;
                                        break;
                                    case Orientation.ZINDEX:
                                        context.prevAttr = Attribute.ZINDEX;
                                        context.curAttr = Attribute.ZINDEX;
                                        context.relation.constant = !prevView ? 0 : context.relation.constant || 'default';
                                        break;
                                }
                                context.constraints.push({
                                    view1: prevView,
                                    attr1: context.prevAttr,
                                    relation: context.relation.relation,
                                    view2: curView,
                                    attr2: context.curAttr,
                                    multiplier: context.relation.multiplier,
                                    constant: context.relation.constant === 'default' || !context.relation.constant ? context.relation.constant : -context.relation.constant,
                                    priority: context.relation.priority
                                });
                            }
                        }
                    }

                    //
                    // Process view size constraints
                    //
                    var constraints = item.constraints;
                    if (constraints) {
                        for (var n = 0; n < constraints.length; n++) {
                            context.prevAttr = context.horizontal ? Attribute.WIDTH : Attribute.HEIGHT;
                            context.curAttr = constraints[n].view || constraints[n].multiplier ? constraints[n].attribute || context.prevAttr : constraints[n].variable ? Attribute.VARIABLE : Attribute.CONST;
                            context.constraints.push({
                                view1: curView,
                                attr1: context.prevAttr,
                                relation: constraints[n].relation,
                                view2: constraints[n].view,
                                attr2: context.curAttr,
                                multiplier: constraints[n].multiplier,
                                constant: constraints[n].constant,
                                priority: constraints[n].priority
                            });
                        }
                    }

                    //
                    // Process cascaded data (child stack-views)
                    //
                    if (item.cascade) {
                        _processCascade(context, item.cascade, item);
                    }
                }
            }
        } else if (item !== ',') {
            context.prevViews = curViews;
            curViews = [];
            context.relation = item[0];
            if (context.prevViews !== undefined) {
                if (context.relation.equalSpacing) {
                    _processEqualSpacer(context, stackView);
                }
                if (context.relation.multiplier) {
                    _processProportionalSpacer(context, stackView);
                }
            }
        }
    }

    if (stackView) {
        subView = context.subViews[stackView];
        if (!subView) {
            subView = {
                orientations: context.orientation
            };
            context.subViews[stackView] = subView;
        } else if (subView.stack) {
            var err = new Error('A stack named "' + stackView + '" has already been created');
            err.column = parentItem.$parserOffset + 1;
            throw err;
        }
        subView.stack = {
            orientation: context.orientation,
            processedOrientations: context.orientation,
            subViews: subViews
        };
        _processStackView(context, stackView, subView);
    }
}

var metaInfoCategories = ['viewport', 'spacing', 'colors', 'shapes', 'widths', 'heights'];

/**
 * VisualFormat
 *
 * @namespace VisualFormat
 */

var VisualFormat = (function() {
    function VisualFormat() {
        _classCallCheck(this, VisualFormat);
    }

    _createClass(VisualFormat, null, [{
        key: 'parseLine',

        /**
         * Parses a single line of vfl into an array of constraint definitions.
         *
         * When the visual-format could not be succesfully parsed an exception is thrown containing
         * additional info about the parse error and column position.
         *
         * @param {String} visualFormat Visual format string (cannot contain line-endings!).
         * @param {Object} [options] Configuration options.
         * @param {Boolean} [options.extended] When set to true uses the extended syntax (default: false).
         * @param {String} [options.outFormat] Output format (`constraints` or `raw`) (default: `constraints`).
         * @param {Number} [options.lineIndex] Line-index used when auto generating equal-spacing constraints.
         * @return {Array} Array of constraint definitions.
         */
        value: function parseLine(visualFormat, options) {
            if (visualFormat.length === 0 || options && options.extended && visualFormat.indexOf('//') === 0) {
                return [];
            }
            var res = options && options.extended ? parserExt.parse(visualFormat) : parser.parse(visualFormat);
            if (options && options.outFormat === 'raw') {
                return [res];
            }
            var context = {
                constraints: [],
                lineIndex: (options ? options.lineIndex : undefined) || 1,
                subViews: (options ? options.subViews : undefined) || {}
            };
            switch (res.orientation) {
                case 'horizontal':
                    context.orientation = Orientation.HORIZONTAL;
                    context.horizontal = true;
                    _processCascade(context, res.cascade, null);
                    break;
                case 'vertical':
                    context.orientation = Orientation.VERTICAL;
                    _processCascade(context, res.cascade, null);
                    break;
                case 'horzvert':
                    context.orientation = Orientation.HORIZONTAL;
                    context.horizontal = true;
                    _processCascade(context, res.cascade, null);
                    context = {
                        constraints: context.constraints,
                        lineIndex: context.lineIndex,
                        subViews: context.subViews,
                        orientation: Orientation.VERTICAL
                    };
                    _processCascade(context, res.cascade, null);
                    break;
                case 'zIndex':
                    context.orientation = Orientation.ZINDEX;
                    _processCascade(context, res.cascade, null);
                    break;
            }
            return context.constraints;
        }

        /**
         * Parses one or more visual format strings into an array of constraint definitions.
         *
         * When the visual-format could not be succesfully parsed an exception is thrown containing
         * additional info about the parse error and column position.
         *
         * @param {String|Array} visualFormat One or more visual format strings.
         * @param {Object} [options] Configuration options.
         * @param {Boolean} [options.extended] When set to true uses the extended syntax (default: false).
         * @param {Boolean} [options.strict] When set to false trims any leading/trailing spaces and ignores empty lines (default: true).
         * @param {String} [options.lineSeperator] String that defines the end of a line (default `\n`).
         * @param {String} [options.outFormat] Output format (`constraints` or `raw`) (default: `constraints`).
         * @return {Array} Array of constraint definitions.
         */
    }, {
        key: 'parse',
        value: function parse(visualFormat, options) {
            var lineSeperator = options && options.lineSeperator ? options.lineSeperator : '\n';
            if (!Array.isArray(visualFormat) && visualFormat.indexOf(lineSeperator) < 0) {
                try {
                    return this.parseLine(visualFormat, options);
                } catch (err) {
                    err.source = visualFormat;
                    throw err;
                }
            }

            // Decompose visual-format into an array of strings, and within those strings
            // search for line-endings, and treat each line as a seperate visual-format.
            visualFormat = Array.isArray(visualFormat) ? visualFormat : [visualFormat];
            var lines = undefined;
            var constraints = [];
            var lineIndex = 0;
            var line = undefined;
            var parseOptions = {
                lineIndex: lineIndex,
                extended: options && options.extended,
                strict: options && options.strict !== undefined ? options.strict : true,
                outFormat: options ? options.outFormat : undefined,
                subViews: {}
            };
            try {
                for (var i = 0; i < visualFormat.length; i++) {
                    lines = visualFormat[i].split(lineSeperator);
                    for (var j = 0; j < lines.length; j++) {
                        line = lines[j];
                        lineIndex++;
                        parseOptions.lineIndex = lineIndex;
                        if (!parseOptions.strict) {
                            line = line.trim();
                        }
                        if (parseOptions.strict || line.length) {
                            constraints = constraints.concat(this.parseLine(line, parseOptions));
                        }
                    }
                }
            } catch (err) {
                err.source = line;
                err.line = lineIndex;
                throw err;
            }
            return constraints;
        }

        /**
         * Parses meta information from the comments in the VFL.
         *
         * Additional meta information can be specified in the comments
         * for previewing and rendering purposes. For instance, the view-port
         * aspect-ratio, sub-view widths and colors, can be specified. The
         * following example renders three colored circles in the visual-format editor:
         *
         * ```vfl
         * //viewport aspect-ratio:3/1 max-height:300
         * //colors red:#FF0000 green:#00FF00 blue:#0000FF
         * //shapes red:circle green:circle blue:circle
         * H:|-[row:[red(green,blue)]-[green]-[blue]]-|
         * V:|[row]|
         * ```
         *
         * Supported categories and properties:
         *
         * |Category|Property|Example|
         * |--------|--------|-------|
         * |`viewport`|`aspect-ratio:{width}/{height}`|`//viewport aspect-ratio:16/9`|
         * ||`width:[{number}/intrinsic]`|`//viewport width:10`|
         * ||`height:[{number}/intrinsic]`|`//viewport height:intrinsic`|
         * ||`min-width:{number}`|
         * ||`max-width:{number}`|
         * ||`min-height:{number}`|
         * ||`max-height:{number}`|
         * |`spacing`|`[{number}/array]`|`//spacing:8` or `//spacing:[10, 20, 5]`|
         * |`widths`|`{view-name}:[{number}/intrinsic]`|`//widths subview1:100`|
         * |`heights`|`{view-name}:[{number}/intrinsic]`|`//heights subview1:intrinsic`|
         * |`colors`|`{view-name}:{color}`|`//colors redview:#FF0000 blueview:#00FF00`|
         * |`shapes`|`{view-name}:[circle/square]`|`//shapes avatar:circle`|
         *
         * @param {String|Array} visualFormat One or more visual format strings.
         * @param {Object} [options] Configuration options.
         * @param {String} [options.lineSeperator] String that defines the end of a line (default `\n`).
         * @param {String} [options.prefix] When specified, also processes the categories using that prefix (e.g. "-dev-viewport max-height:10").
         * @return {Object} meta-info
         */
    }, {
        key: 'parseMetaInfo',
        value: function parseMetaInfo(visualFormat, options) {
            var lineSeperator = options && options.lineSeperator ? options.lineSeperator : '\n';
            var prefix = options ? options.prefix : undefined;
            visualFormat = Array.isArray(visualFormat) ? visualFormat : [visualFormat];
            var metaInfo = {};
            var key;
            for (var k = 0; k < visualFormat.length; k++) {
                var lines = visualFormat[k].split(lineSeperator);
                for (var i = 0; i < lines.length; i++) {
                    var line = lines[i];
                    for (var c = 0; c < metaInfoCategories.length; c++) {
                        for (var s = 0; s < (prefix ? 2 : 1); s++) {
                            var category = metaInfoCategories[c];
                            var prefixedCategory = (s === 0 ? '' : prefix) + category;
                            if (line.indexOf('//' + prefixedCategory + ' ') === 0) {
                                var items = line.substring(3 + prefixedCategory.length).split(' ');
                                for (var j = 0; j < items.length; j++) {
                                    metaInfo[category] = metaInfo[category] || {};
                                    var item = items[j].split(':');
                                    var names = _getRange(item[0], true);
                                    for (var r = 0; r < names.length; r++) {
                                        metaInfo[category][names[r]] = item.length > 1 ? item[1] : '';
                                    }
                                }
                            } else if (line.indexOf('//' + prefixedCategory + ':') === 0) {
                                metaInfo[category] = line.substring(3 + prefixedCategory.length);
                            }
                        }
                    }
                }
            }
            if (metaInfo.viewport) {
                var viewport = metaInfo.viewport;
                var aspectRatio = viewport['aspect-ratio'];
                if (aspectRatio) {
                    aspectRatio = aspectRatio.split('/');
                    viewport['aspect-ratio'] = parseInt(aspectRatio[0]) / parseInt(aspectRatio[1]);
                }
                if (viewport.height !== undefined) {
                    viewport.height = viewport.height === 'intrinsic' ? true : parseInt(viewport.height);
                }
                if (viewport.width !== undefined) {
                    viewport.width = viewport.width === 'intrinsic' ? true : parseInt(viewport.width);
                }
                if (viewport['max-height'] !== undefined) {
                    viewport['max-height'] = parseInt(viewport['max-height']);
                }
                if (viewport['max-width'] !== undefined) {
                    viewport['max-width'] = parseInt(viewport['max-width']);
                }
                if (viewport['min-height'] !== undefined) {
                    viewport['min-height'] = parseInt(viewport['min-height']);
                }
                if (viewport['min-width'] !== undefined) {
                    viewport['min-width'] = parseInt(viewport['min-width']);
                }
            }
            if (metaInfo.widths) {
                for (key in metaInfo.widths) {
                    var width = metaInfo.widths[key] === 'intrinsic' ? true : parseInt(metaInfo.widths[key]);
                    metaInfo.widths[key] = width;
                    if (width === undefined || isNaN(width)) {
                        delete metaInfo.widths[key];
                    }
                }
            }
            if (metaInfo.heights) {
                for (key in metaInfo.heights) {
                    var height = metaInfo.heights[key] === 'intrinsic' ? true : parseInt(metaInfo.heights[key]);
                    metaInfo.heights[key] = height;
                    if (height === undefined || isNaN(height)) {
                        delete metaInfo.heights[key];
                    }
                }
            }
            if (metaInfo.spacing) {
                var value = JSON.parse(metaInfo.spacing);
                metaInfo.spacing = value;
                if (Array.isArray(value)) {
                    for (var sIdx = 0, len = value.length; sIdx < len; sIdx++) {
                        if (isNaN(value[sIdx])) {
                            delete metaInfo.spacing;
                            break;
                        }
                    }
                } else if (value === undefined || isNaN(value)) {
                    delete metaInfo.spacing;
                }
            }
            return metaInfo;
        }
    }]);

    return VisualFormat;
})();

var SubView = (function() {
    function SubView(options) {
        _classCallCheck(this, SubView);

        this._name = options.name;
        this._type = options.type;
        this._solver = options.solver;
        this._attr = {};
        if (!options.name) {
            if (true) {
                this._attr[Attribute.LEFT] = new c.Variable();
                this._solver.addConstraint(new c.StayConstraint(this._attr[Attribute.LEFT], c.Strength.required));
                this._attr[Attribute.TOP] = new c.Variable();
                this._solver.addConstraint(new c.StayConstraint(this._attr[Attribute.TOP], c.Strength.required));
                this._attr[Attribute.ZINDEX] = new c.Variable();
                this._solver.addConstraint(new c.StayConstraint(this._attr[Attribute.ZINDEX], c.Strength.required));
            } else {
                this._attr[Attribute.LEFT] = new kiwi.Variable();
                this._solver.addConstraint(new kiwi.Constraint(this._attr[Attribute.LEFT], kiwi.Operator.Eq, 0));
                this._attr[Attribute.TOP] = new kiwi.Variable();
                this._solver.addConstraint(new kiwi.Constraint(this._attr[Attribute.TOP], kiwi.Operator.Eq, 0));
                this._attr[Attribute.ZINDEX] = new kiwi.Variable();
                this._solver.addConstraint(new kiwi.Constraint(this._attr[Attribute.ZINDEX], kiwi.Operator.Eq, 0));
            }
        }
    }

    _createClass(SubView, [{
        key: 'toJSON',
        value: function toJSON() {
            return {
                name: this.name,
                left: this.left,
                top: this.top,
                width: this.width,
                height: this.height
            };
        }
    }, {
        key: 'toString',
        value: function toString() {
            JSON.stringify(this.toJSON(), undefined, 2);
        }

        /**
         * Name of the sub-view.
         * @readonly
         * @type {String}
         */
    }, {
        key: 'getValue',

        /**
         * Gets the value of one of the attributes.
         *
         * @param {String|Attribute} attr Attribute name (e.g. 'right', 'centerY', Attribute.TOP).
         * @return {Number} value or `undefined`
         */
        value: function getValue(attr) {
            return this._attr[attr] ? this._attr[attr].value() : undefined;
        }

        /**
         * @private
         */
    }, {
        key: '_getAttr',
        value: function _getAttr(attr) {
            if (this._attr[attr]) {
                return this._attr[attr];
            }
            this._attr[attr] = true ? new c.Variable() : new kiwi.Variable();
            switch (attr) {
                case Attribute.RIGHT:
                    this._getAttr(Attribute.LEFT);
                    this._getAttr(Attribute.WIDTH);
                    if (true) {
                        this._solver.addConstraint(new c.Equation(this._attr[attr], c.plus(this._attr[Attribute.LEFT], this._attr[Attribute.WIDTH])));
                    } else {
                        this._solver.addConstraint(new kiwi.Constraint(this._attr[attr], kiwi.Operator.Eq, this._attr[Attribute.LEFT].plus(this._attr[Attribute.WIDTH])));
                    }
                    break;
                case Attribute.BOTTOM:
                    this._getAttr(Attribute.TOP);
                    this._getAttr(Attribute.HEIGHT);
                    if (true) {
                        this._solver.addConstraint(new c.Equation(this._attr[attr], c.plus(this._attr[Attribute.TOP], this._attr[Attribute.HEIGHT])));
                    } else {
                        this._solver.addConstraint(new kiwi.Constraint(this._attr[attr], kiwi.Operator.Eq, this._attr[Attribute.TOP].plus(this._attr[Attribute.HEIGHT])));
                    }
                    break;
                case Attribute.CENTERX:
                    this._getAttr(Attribute.LEFT);
                    this._getAttr(Attribute.WIDTH);
                    if (true) {
                        this._solver.addConstraint(new c.Equation(this._attr[attr], c.plus(this._attr[Attribute.LEFT], c.divide(this._attr[Attribute.WIDTH], 2))));
                    } else {
                        this._solver.addConstraint(new kiwi.Constraint(this._attr[attr], kiwi.Operator.Eq, this._attr[Attribute.LEFT].plus(this._attr[Attribute.WIDTH].divide(2))));
                    }
                    break;
                case Attribute.CENTERY:
                    this._getAttr(Attribute.TOP);
                    this._getAttr(Attribute.HEIGHT);
                    if (true) {
                        this._solver.addConstraint(new c.Equation(this._attr[attr], c.plus(this._attr[Attribute.TOP], c.divide(this._attr[Attribute.HEIGHT], 2))));
                    } else {
                        this._solver.addConstraint(new kiwi.Constraint(this._attr[attr], kiwi.Operator.Eq, this._attr[Attribute.TOP].plus(this._attr[Attribute.HEIGHT].divide(2))));
                    }
                    break;
            }
            if (!true) {
                this._solver.updateVariables();
            }
            return this._attr[attr];
        }

        /**
         * @private
         */
    }, {
        key: '_getAttrValue',
        value: function _getAttrValue(attr) {
            if (true) {
                return this._getAttr(attr).value;
            } else {
                return this._getAttr(attr).value();
            }
        }
    }, {
        key: 'name',
        get: function get() {
            return this._name;
        }

        /**
         * Left value (`Attribute.LEFT`).
         * @readonly
         * @type {Number}
         */
    }, {
        key: 'left',
        get: function get() {
            return this._getAttrValue(Attribute.LEFT);
        }

        /**
         * Right value (`Attribute.RIGHT`).
         * @readonly
         * @type {Number}
         */
    }, {
        key: 'right',
        get: function get() {
            return this._getAttrValue(Attribute.RIGHT);
        }

        /**
         * Width value (`Attribute.WIDTH`).
         * @type {Number}
         */
    }, {
        key: 'width',
        get: function get() {
            return this._getAttrValue(Attribute.WIDTH);
        }

        /**
         * Height value (`Attribute.HEIGHT`).
         * @readonly
         * @type {Number}
         */
    }, {
        key: 'height',
        get: function get() {
            return this._getAttrValue(Attribute.HEIGHT);
        }

        /**
         * Intrinsic width of the sub-view.
         *
         * Use this property to explicitely set the width of the sub-view, e.g.:
         * ```javascript
         * var view = new AutoLayout.View(AutoLayout.VisualFormat.parse('|[child1][child2]|'), {
         *   width: 500
         * });
         * view.subViews.child1.intrinsicWidth = 100;
         * console.log('child2 width: ' + view.subViews.child2.width); // 400
         * ```
         *
         * @type {Number}
         */
    }, {
        key: 'intrinsicWidth',
        get: function get() {
            return this._intrinsicWidth;
        },
        set: function set(value) {
            if (value !== undefined && value !== this._intrinsicWidth) {
                var attr = this._getAttr(Attribute.WIDTH);
                if (this._intrinsicWidth === undefined) {
                    if (true) {
                        this._solver.addEditVar(attr, new c.Strength('required', this._name ? 998 : 999, 1000, 1000));
                    } else {
                        this._solver.addEditVariable(attr, kiwi.Strength.create(this._name ? 998 : 999, 1000, 1000));
                    }
                }
                this._intrinsicWidth = value;
                this._solver.suggestValue(attr, value);
                if (true) {
                    this._solver.resolve();
                } else {
                    this._solver.updateVariables();
                }
            }
        }

        /**
         * Intrinsic height of the sub-view.
         *
         * See `intrinsicWidth`.
         *
         * @type {Number}
         */
    }, {
        key: 'intrinsicHeight',
        get: function get() {
            return this._intrinsicHeight;
        },
        set: function set(value) {
            if (value !== undefined && value !== this._intrinsicHeight) {
                var attr = this._getAttr(Attribute.HEIGHT);
                if (this._intrinsicHeight === undefined) {
                    if (true) {
                        this._solver.addEditVar(attr, new c.Strength('required', this._name ? 998 : 999, 1000, 1000));
                    } else {
                        this._solver.addEditVariable(attr, kiwi.Strength.create(this._name ? 998 : 999, 1000, 1000));
                    }
                }
                this._intrinsicHeight = value;
                this._solver.suggestValue(attr, value);
                if (true) {
                    this._solver.resolve();
                } else {
                    this._solver.updateVariables();
                }
            }
        }

        /**
         * Top value (`Attribute.TOP`).
         * @readonly
         * @type {Number}
         */
    }, {
        key: 'top',
        get: function get() {
            return this._getAttrValue(Attribute.TOP);
        }

        /**
         * Bottom value (`Attribute.BOTTOM`).
         * @readonly
         * @type {Number}
         */
    }, {
        key: 'bottom',
        get: function get() {
            return this._getAttrValue(Attribute.BOTTOM);
        }

        /**
         * Horizontal center (`Attribute.CENTERX`).
         * @readonly
         * @type {Number}
         */
    }, {
        key: 'centerX',
        get: function get() {
            return this._getAttrValue(Attribute.CENTERX);
        }

        /**
         * Vertical center (`Attribute.CENTERY`).
         * @readonly
         * @type {Number}
         */
    }, {
        key: 'centerY',
        get: function get() {
            return this._getAttrValue(Attribute.CENTERY);
        }

        /**
         * Z-index (`Attribute.ZINDEX`).
         * @readonly
         * @type {Number}
         */
    }, {
        key: 'zIndex',
        get: function get() {
            return this._getAttrValue(Attribute.ZINDEX);
        }

        /**
         * Returns the type of the sub-view.
         * @readonly
         * @type {String}
         */
    }, {
        key: 'type',
        get: function get() {
            return this._type;
        }
    }]);

    return SubView;
})();

var defaultPriorityStrength = true ? new c.Strength('defaultPriority', 0, 1000, 1000) : kiwi.Strength.create(0, 1000, 1000);

function _getConst(name, value) {
    if (true) {
        var vr = new c.Variable({
            value: value
        });
        this._solver.addConstraint(new c.StayConstraint(vr, c.Strength.required, 0));
        return vr;
    } else {
        var vr = new kiwi.Variable();
        this._solver.addConstraint(new kiwi.Constraint(vr, kiwi.Operator.Eq, value));
        return vr;
    }
}

function _getSubView(viewName) {
    if (!viewName) {
        return this._parentSubView;
    } else if (viewName.name) {
        this._subViews[viewName.name] = this._subViews[viewName.name] || new SubView({
            name: viewName.name,
            solver: this._solver
        });
        this._subViews[viewName.name]._type = this._subViews[viewName.name]._type || viewName.type;
        return this._subViews[viewName.name];
    } else {
        this._subViews[viewName] = this._subViews[viewName] || new SubView({
            name: viewName,
            solver: this._solver
        });
        return this._subViews[viewName];
    }
}

function _getSpacing(constraint) {
    var index = 4;
    if (!constraint.view1 && constraint.attr1 === 'left') {
        index = 3;
    } else if (!constraint.view1 && constraint.attr1 === 'top') {
        index = 0;
    } else if (!constraint.view2 && constraint.attr2 === 'right') {
        index = 1;
    } else if (!constraint.view2 && constraint.attr2 === 'bottom') {
        index = 2;
    } else {
        switch (constraint.attr1) {
            case 'left':
            case 'right':
            case 'centerX':
            case 'leading':
            case 'trailing':
                index = 4;
                break;
            case 'zIndex':
                index = 6;
                break;
            default:
                index = 5;
        }
    }
    this._spacingVars = this._spacingVars || new Array(7);
    this._spacingExpr = this._spacingExpr || new Array(7);
    if (!this._spacingVars[index]) {
        if (true) {
            this._spacingVars[index] = new c.Variable();
            this._solver.addEditVar(this._spacingVars[index]);
            this._spacingExpr[index] = c.minus(0, this._spacingVars[index]);
        } else {
            this._spacingVars[index] = new kiwi.Variable();
            this._solver.addEditVariable(this._spacingVars[index], kiwi.Strength.create(999, 1000, 1000));
            this._spacingExpr[index] = this._spacingVars[index].multiply(-1);
        }
        this._solver.suggestValue(this._spacingVars[index], this._spacing[index]);
    }
    return this._spacingExpr[index];
}

function _addConstraint(constraint) {
    //this.constraints.push(constraint);
    var relation = undefined;
    var multiplier = constraint.multiplier !== undefined ? constraint.multiplier : 1;
    var constant = constraint.constant !== undefined ? constraint.constant : 0;
    if (constant === 'default') {
        constant = _getSpacing.call(this, constraint);
    }
    var attr1 = _getSubView.call(this, constraint.view1)._getAttr(constraint.attr1);
    var attr2 = undefined;
    if (true) {
        if (constraint.attr2 === Attribute.CONST) {
            attr2 = _getConst.call(this, undefined, constraint.constant);
        } else {
            attr2 = _getSubView.call(this, constraint.view2)._getAttr(constraint.attr2);
            if (multiplier !== 1 && constant) {
                attr2 = c.plus(c.times(attr2, multiplier), constant);
            } else if (constant) {
                attr2 = c.plus(attr2, constant);
            } else if (multiplier !== 1) {
                attr2 = c.times(attr2, multiplier);
            }
        }
        var strength = constraint.priority !== undefined && constraint.priority < 1000 ? new c.Strength('priority', 0, constraint.priority, 1000) : defaultPriorityStrength;
        switch (constraint.relation) {
            case Relation.EQU:
                relation = new c.Equation(attr1, attr2, strength);
                break;
            case Relation.GEQ:
                relation = new c.Inequality(attr1, c.GEQ, attr2, strength);
                break;
            case Relation.LEQ:
                relation = new c.Inequality(attr1, c.LEQ, attr2, strength);
                break;
            default:
                throw 'Invalid relation specified: ' + constraint.relation;
        }
    } else {
        if (constraint.attr2 === Attribute.CONST) {
            attr2 = _getConst.call(this, undefined, constraint.constant);
        } else {
            attr2 = _getSubView.call(this, constraint.view2)._getAttr(constraint.attr2);
            if (multiplier !== 1 && constant) {
                attr2 = attr2.multiply(multiplier).plus(constant);
            } else if (constant) {
                attr2 = attr2.plus(constant);
            } else if (multiplier !== 1) {
                attr2 = attr2.multiply(multiplier);
            }
        }
        var strength = constraint.priority !== undefined && constraint.priority < 1000 ? kiwi.Strength.create(0, constraint.priority, 1000) : defaultPriorityStrength;
        switch (constraint.relation) {
            case Relation.EQU:
                relation = new kiwi.Constraint(attr1, kiwi.Operator.Eq, attr2, strength);
                break;
            case Relation.GEQ:
                relation = new kiwi.Constraint(attr1, kiwi.Operator.Ge, attr2, strength);
                break;
            case Relation.LEQ:
                relation = new kiwi.Constraint(attr1, kiwi.Operator.Le, attr2, strength);
                break;
            default:
                throw 'Invalid relation specified: ' + constraint.relation;
        }
    }
    this._solver.addConstraint(relation);
}

function _compareSpacing(old, newz) {
    if (old === newz) {
        return true;
    }
    if (!old || !newz) {
        return false;
    }
    for (var i = 0; i < 7; i++) {
        if (old[i] !== newz[i]) {
            return false;
        }
    }
    return true;
}

/**
 * AutoLayoutJS API reference.
 *
 * ### Index
 *
 * |Entity|Type|Description|
 * |---|---|---|
 * |[AutoLayout](#autolayout)|`namespace`|Top level AutoLayout object.|
 * |[VisualFormat](#autolayoutvisualformat--object)|`namespace`|Parses VFL into constraints.|
 * |[View](#autolayoutview)|`class`|Main entity for adding & evaluating constraints.|
 * |[SubView](#autolayoutsubview--object)|`class`|SubView's are automatically created when constraints are added to views. They give access to the evaluated results.|
 * |[Attribute](#autolayoutattribute--enum)|`enum`|Attribute types that are supported when adding constraints.|
 * |[Relation](#autolayoutrelation--enum)|`enum`|Relationship types that are supported when adding constraints.|
 * |[Priority](#autolayoutpriority--enum)|`enum`|Default priority values for when adding constraints.|
 *
 * ### AutoLayout
 *
 * @module AutoLayout
 */

var View = (function() {

    /**
     * @class View
     * @param {Object} [options] Configuration options.
     * @param {Number} [options.width] Initial width of the view.
     * @param {Number} [options.height] Initial height of the view.
     * @param {Number|Object} [options.spacing] Spacing for the view (default: 8) (see `setSpacing`).
     * @param {Array} [options.constraints] One or more constraint definitions (see `addConstraints`).
     */

    function View(options) {
        _classCallCheck(this, View);

        this._solver = true ? new c.SimplexSolver() : new kiwi.Solver();
        this._subViews = {};
        //this._spacing = undefined;
        this._parentSubView = new SubView({
            solver: this._solver
        });
        this.setSpacing(options && options.spacing !== undefined ? options.spacing : 8);
        //this.constraints = [];
        if (options) {
            if (options.width !== undefined || options.height !== undefined) {
                this.setSize(options.width, options.height);
            }
            if (options.constraints) {
                this.addConstraints(options.constraints);
            }
        }
    }

    /**
     * Sets the width and height of the view.
     *
     * @param {Number} width Width of the view.
     * @param {Number} height Height of the view.
     * @return {View} this
     */

    _createClass(View, [{
        key: 'setSize',
        value: function setSize(width, height /*, depth*/ ) {
            this._parentSubView.intrinsicWidth = width;
            this._parentSubView.intrinsicHeight = height;
            return this;
        }

        /**
         * Width that was set using `setSize`.
         * @readonly
         * @type {Number}
         */
    }, {
        key: 'setSpacing',

        /**
         * Sets the spacing for the view.
         *
         * The spacing can be set for 7 different variables:
         * `top`, `right`, `bottom`, `left`, `width`, `height` and `zIndex`. The `left`-spacing is
         * used when a spacer is used between the parent-view and a sub-view (e.g. `|-[subView]`).
         * The same is true for the `right`, `top` and `bottom` spacers. The `width` and `height` are
         * used for spacers in between sub-views (e.g. `[view1]-[view2]`).
         *
         * Instead of using the full spacing syntax, it is also possible to use shorthand notations:
         *
         * |Syntax|Type|Description|
         * |---|---|---|
         * |`[top, right, bottom, left, width, height, zIndex]`|Array(7)|Full syntax including z-index **(clockwise order)**.|
         * |`[top, right, bottom, left, width, height]`|Array(6)|Full horizontal & vertical spacing syntax (no z-index) **(clockwise order)**.|
         * |`[horizontal, vertical, zIndex]`|Array(3)|Horizontal = left, right, width, vertical = top, bottom, height.|
         * |`[horizontal, vertical]`|Array(2)|Horizontal = left, right, width, vertical = top, bottom, height, z-index = 1.|
         * |`spacing`|Number|Horizontal & vertical spacing are all the same, z-index = 1.|
         *
         * Examples:
         * ```javascript
         * view.setSpacing(10); // horizontal & vertical spacing 10
         * view.setSpacing([10, 15, 2]); // horizontal spacing 10, vertical spacing 15, z-axis spacing 2
         * view.setSpacing([10, 20, 10, 20, 5, 5]); // top, right, bottom, left, horizontal, vertical
         * view.setSpacing([10, 20, 10, 20, 5, 5, 1]); // top, right, bottom, left, horizontal, vertical, z
         * ```
         *
         * @param {Number|Array} spacing
         * @return {View} this
         */
        value: function setSpacing(spacing) {
            // convert spacing into array: [top, right, bottom, left, horz, vert, z-index]
            switch (Array.isArray(spacing) ? spacing.length : -1) {
                case -1:
                    spacing = [spacing, spacing, spacing, spacing, spacing, spacing, 1];
                    break;
                case 1:
                    spacing = [spacing[0], spacing[0], spacing[0], spacing[0], spacing[0], spacing[0], 1];
                    break;
                case 2:
                    spacing = [spacing[1], spacing[0], spacing[1], spacing[0], spacing[0], spacing[1], 1];
                    break;
                case 3:
                    spacing = [spacing[1], spacing[0], spacing[1], spacing[0], spacing[0], spacing[1], spacing[2]];
                    break;
                case 6:
                    spacing = [spacing[0], spacing[1], spacing[2], spacing[3], spacing[4], spacing[5], 1];
                    break;
                case 7:
                    break;
                default:
                    throw 'Invalid spacing syntax';
            }
            if (!_compareSpacing(this._spacing, spacing)) {
                this._spacing = spacing;
                // update spacing variables
                if (this._spacingVars) {
                    for (var i = 0; i < this._spacingVars.length; i++) {
                        if (this._spacingVars[i]) {
                            this._solver.suggestValue(this._spacingVars[i], this._spacing[i]);
                        }
                    }
                    if (true) {
                        this._solver.resolve();
                    } else {
                        this._solver.updateVariables();
                    }
                }
            }
            return this;
        }

        /**
         * Adds a constraint definition.
         *
         * A constraint definition has the following format:
         *
         * ```javascript
         * constraint: {
         *   view1: {String},
         *   attr1: {AutoLayout.Attribute},
         *   relation: {AutoLayout.Relation},
         *   view2: {String},
         *   attr2: {AutoLayout.Attribute},
         *   multiplier: {Number},
         *   constant: {Number},
         *   priority: {Number}(0..1000)
         * }
         * ```
         * @param {Object} constraint Constraint definition.
         * @return {View} this
         */
    }, {
        key: 'addConstraint',
        value: function addConstraint(constraint) {
            _addConstraint.call(this, constraint);
            if (!true) {
                this._solver.updateVariables();
            }
            return this;
        }

        /**
         * Adds one or more constraint definitions.
         *
         * A constraint definition has the following format:
         *
         * ```javascript
         * constraint: {
         *   view1: {String},
         *   attr1: {AutoLayout.Attribute},
         *   relation: {AutoLayout.Relation},
         *   view2: {String},
         *   attr2: {AutoLayout.Attribute},
         *   multiplier: {Number},
         *   constant: {Number},
         *   priority: {Number}(0..1000)
         * }
         * ```
         * @param {Array} constraints One or more constraint definitions.
         * @return {View} this
         */
    }, {
        key: 'addConstraints',
        value: function addConstraints(constraints) {
            for (var j = 0; j < constraints.length; j++) {
                _addConstraint.call(this, constraints[j]);
            }
            if (!true) {
                this._solver.updateVariables();
            }
            return this;
        }

        /**
         * Dictionary of `SubView` objects that have been created when adding constraints.
         * @readonly
         * @type {Object.SubView}
         */
    }, {
        key: 'width',
        get: function get() {
            return this._parentSubView.intrinsicWidth;
        }

        /**
         * Height that was set using `setSize`.
         * @readonly
         * @type {Number}
         */
    }, {
        key: 'height',
        get: function get() {
            return this._parentSubView.intrinsicHeight;
        }

        /**
         * Width that is calculated from the constraints and the `.intrinsicWidth` of
         * the sub-views.
         *
         * When the width has been explicitely set using `setSize`, the fittingWidth
         * will **always** be the same as the explicitely set width. To calculate the size
         * based on the content, use:
         * ```javascript
         * var view = new AutoLayout.View({
         *   constraints: VisualFormat.parse('|-[view1]-[view2]-'),
         *   spacing: 20
         * });
         * view.subViews.view1.intrinsicWidth = 100;
         * view.subViews.view2.intrinsicWidth = 100;
         * console.log('fittingWidth: ' + view.fittingWidth); // 260
         * ```
         *
         * @readonly
         * @type {Number}
         */
    }, {
        key: 'fittingWidth',
        get: function get() {
            return this._parentSubView.width;
        }

        /**
         * Height that is calculated from the constraints and the `.intrinsicHeight` of
         * the sub-views.
         *
         * See `.fittingWidth`.
         *
         * @readonly
         * @type {Number}
         */
    }, {
        key: 'fittingHeight',
        get: function get() {
            return this._parentSubView.height;
        }
    }, {
        key: 'subViews',
        get: function get() {
            return this._subViews;
        }

        /**
         * Checks whether the constraints incompletely specify the location
         * of the subViews.
         * @private
         */
        //get hasAmbiguousLayout() {
        // Todo
        //}
    }]);

    return View;
})();

var AutoLayout = {
    Attribute: Attribute,
    Relation: Relation,
    Priority: Priority,
    VisualFormat: VisualFormat,
    View: View,
    SubView: SubView
    //DOM: DOM
};

module.exports = AutoLayout;
